<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qonnect - Organization Hierarchy Chart v2.7</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <style>
        .employee-card {
            position: relative;
            width: 200px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            padding: 20px;
            text-align: center;
        }

        .employee-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        .google-card {
            border: 1px solid transparent !important;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(45deg, #4285f4, #ea4335, #fbbc05, #34a853) border-box !important;
        }

        .qt-card {
            background: white;
            border: 2px solid #5748c3;
        }

        .connector-line {
            width: 2px;
            height: 40px;
            background: linear-gradient(to bottom, #e5e7eb, #9ca3af);
            margin: 20px auto;
        }

        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            max-height: 400px;
            overflow-y: auto;
            z-index: 50;
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f9fafb;
        }

        .text-xxs {
            font-size: 0.625rem;
            line-height: 0.75rem;
        }

        .connection-count-hidden {
            display: none !important;
        }

        .steps-badge-hidden {
            display: none !important;
        }

        /* Three-column vertical hierarchy layout */
        .tree-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 200px;
            padding: 3rem 2rem;
            min-height: 400px;
            justify-items: center;
            align-items: start;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            width: 100%;
        }

        /* Center the entire hierarchy section */
        #mainContent {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 80vh;
        }

        /* Each column */
        .hierarchy-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            position: relative;
            width: 100%;
        }

        /* Person box */
        .person-box {
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            width: 220px;
            min-width: 220px;
            max-width: 220px;
            height: 200px;
            min-height: 200px;
            max-height: 200px;
            text-align: center;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .person-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        /* Google employee styling */
        .person-box.google-employee {
            border: 1px solid transparent !important;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(45deg, #4285f4, #ea4335, #fbbc05, #34a853) border-box !important;
            border-radius: 12px !important;
        }

        /* QT employee styling */
        .person-box.qt-employee {
            background: white;
            border: 3px solid #5748c3;
        }

        .person-box .avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            margin: 0 auto 12px;
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: bold;
            color: #4b5563;
        }

        .person-box .avatar.google {
            background: linear-gradient(135deg, #dbeafe 0%, #e9d5ff 100%);
        }

        .person-box .avatar.qt {
            background: linear-gradient(135deg, #f3e8ff 0%, #dbeafe 100%);
        }

        .person-box .name {
            font-weight: bold;
            font-size: 1rem;
            color: #1f2937;
            margin-bottom: 4px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .person-box .designation {
            font-size: 0.8rem;
            color: #6b7280;
            margin-bottom: 8px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .person-box .ldap {
            font-size: 0.7rem;
            color: #9ca3af;
            font-family: monospace;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Vertical connector line (employee reports to manager) */
        .vertical-arrow {
            width: 2px;
            height: 50px;
            background: rgba(51, 51, 51, 0.3);
            position: relative;
            margin: 15px 0;
        }

        /* Horizontal connector line between columns with arrow */
        .horizontal-connector {
            position: absolute;
            height: 2px;
            background: rgba(51, 51, 51, 0.3);
            z-index: 1;
            margin: 0 10px;
        }


        /* Mobile responsive */
        @media (max-width: 768px) {
            .tree-container {
                grid-template-columns: 1fr;
                gap: 40px;
            }
            .horizontal-connector {
                display: none;
            }
        }

        /* Column labels */
        .column-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 10px;
            text-align: center;
        }

        .connection-btn {
            position: relative;
            border-radius: 50%;
            height: 2.5rem;
            width: 2.5rem;
            padding: 0;
            background-color: rgb(254 249 195);
            border: 1px solid rgb(250 204 21);
            color: rgb(161 98 7);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            user-select: none;
        }

        .connection-btn:hover {
            background-color: rgb(254 240 138);
        }

        .connection-btn:active {
            transform: scale(0.95);
        }

        .connection-count {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            background-color: rgb(161 98 7);
            color: white;
            font-size: 0.75rem;
            border-radius: 50%;
            height: 1.25rem;
            width: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .unified-card {
            background-color: white;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            transition: all 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            min-height: 200px;
            max-height: 200px;
            width: 200px;
            justify-content: center;
            position: relative;
        }

        .unified-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px -1px rgb(0 0 0 / 0.1);
        }

        .google-border {
            border: 3px solid transparent;
            border-image-slice: 1;
            border-image-source: linear-gradient(90deg, #4285f4, #db4437, #f4b400, #0f9d58);
        }

        .qt-border {
            border: 3px solid #5748c3;
        }

        /* Horizontal connection container for side-by-side cards */
        .horizontal-connection-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            position: relative;
            margin: 0;
        }

        /* Cards in horizontal connection */
        .connection-card {
            position: relative;
            z-index: 1;
            min-width: 200px;
        }

        /* Arrow connector between connection cards */
        .horizontal-connection-container::before {
            content: "→";
            font-size: 30px;
            color: #3b82f6;
            font-weight: bold;
            z-index: 2;
        }

        /* Connection strength badges */
        .connection-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 1px 6px;
            font-size: 8px;
            font-weight: 500;
            border-radius: 9999px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            z-index: 10;
            opacity: 0.85;
        }

        .badge-strong {
            background-color: rgba(220, 252, 231, 0.7);
            color: #166534;
            border: 1px solid rgba(134, 239, 172, 0.5);
        }

        .badge-medium {
            background-color: rgba(254, 249, 195, 0.7);
            color: #854d0e;
            border: 1px solid rgba(252, 211, 77, 0.5);
        }

        .badge-weak {
            background-color: rgba(254, 226, 226, 0.7);
            color: #991b1b;
            border: 1px solid rgba(252, 165, 165, 0.5);
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900">
    <nav class="w-full p-3 md:p-4 border-b border-gray-200 bg-[#212559] backdrop-blur-sm sticky top-0 z-40">
        <div class="container mx-auto flex items-center justify-between">
            <a href="/smartstakeholdersearch/" class="flex items-center gap-2 md:gap-5">
                <i class="fas fa-project-diagram text-xl md:text-2xl text-primary text-white"></i>
                <h1 class="text-lg md:text-2xl font-bold text-white">Qonnect</h1>
            </a>
            <div class="flex items-center gap-2 md:gap-4">
                <a href="/smartstakeholdersearch/" class="p-2 md:px-4 md:py-2 text-white hover:bg-white/10 rounded-lg transition-all duration-200 flex items-center gap-2">
                    <i class="fas fa-home"></i>
                    <span class="hidden md:inline">Home</span>
                </a>
                <a href="/smartstakeholdersearch/declare" class="p-2 md:px-4 md:py-2 text-white hover:bg-white/10 rounded-lg transition-all duration-200 flex items-center gap-2">
                    <i class="fas fa-handshake"></i>
                    <span class="hidden md:inline">Declare</span>
                </a>
                <a href="/smartstakeholdersearch/logout" class="p-2 md:px-4 md:py-2 text-white hover:bg-red-600/90 bg-red-500 rounded-lg transition-all duration-200 flex items-center gap-2">
                    <i class="fas fa-sign-out-alt"></i>
                    <span class="hidden md:inline">Logout</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="max-w-7xl p-8 mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-2xl font-bold">Organization Hierarchy Chart</h1>
            <p class="text-gray-600 mt-2">Search for Google employees to find their connections to the QT team.</p>
        </div>

        <div class="flex justify-center mb-8">
            <div class="relative w-full max-w-md">
                <div class="relative">
                    <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4"></i>
                    <input type="text" id="searchInput" placeholder="Search Google employees..."
                           class="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div id="suggestions" class="suggestions hidden"></div>
            </div>
        </div>

        <div id="mainContent">
            <div class="text-center text-gray-500 py-16">
                <p>Search and select a Google employee to find their connections to the QT team.</p>
            </div>
        </div>
    </div>

    <script>
        let googleEmployees = [];
        let coreTeam = [];
        let selectedEmployee = null;

        // Performance: Add request cache to prevent duplicate API calls
        const requestCache = new Map();
        const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

        async function cachedFetch(url) {
            const now = Date.now();
            if (requestCache.has(url)) {
                const {data, timestamp} = requestCache.get(url);
                if (now - timestamp < CACHE_TTL) {
                    return data;
                }
            }

            const response = await fetch(url);
            const data = await response.json();
            requestCache.set(url, {data, timestamp: now});
            return data;
        }

        async function loadFlaskData() {
            try {
                const googleResponse = await fetch('/smartstakeholdersearch/api/google-employees');
                if (googleResponse.ok) {
                    const data = await googleResponse.json();
                    googleEmployees = data.map(emp => ({
                        ldap: emp.ldap,
                        email: emp.email || emp.ldap + '@google.com',
                        avatar: emp['MOMA Photo URL'] || emp.avatar || null,
                        name: emp.name,
                        company: emp.company || "GOOGLE",
                        designation: emp.designation,
                        organisation: emp.organisation || emp.department || "Google",
                        manager: emp.manager || null,
                    }));
                }

                const qtResponse = await fetch('/smartstakeholdersearch/api/qt-team');
                if (qtResponse.ok) {
                    const qtData = await qtResponse.json();
                    if (qtData && qtData.length > 0) {
                        coreTeam = qtData.map(emp => ({
                            ldap: emp.ldap,
                            email: emp.email || emp.ldap + '@qualitestgroup.com',
                            avatar: emp.avatar || null,
                            name: emp.name,
                            company: emp.company || "QT",
                            designation: emp.designation,
                            organisation: emp.organisation || emp.department || "QT",
                        }));
                    }
                }


            } catch (error) {
            }
        }

        function getInitials(name) {
            if (!name) return 'NA';
            return name.split(' ').map(word => word.charAt(0).toUpperCase()).join('').substring(0, 2);
        }

        function isValidImageUrl(url) {
            return url && url.trim() !== '' && (url.startsWith('http://') || url.startsWith('https://'));
        }

        function createEmployeeCard(employee) {
            if (!employee) return document.createElement("div");

            const card = document.createElement("div");
            const isQt = employee.company === 'QT' || employee.company === 'Qualitest';
            card.className = `employee-card ${isQt ? 'qt-card' : 'google-card'}`;

            let avatarHtml = '';
            if (isQt) {
                // QT employees show only initials
                avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-purple-100 to-blue-100 flex items-center justify-center">
                  <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                </div>`;
            } else {
                // Google employees can have avatars or initials
                if (isValidImageUrl(employee.avatar)) {
                    avatarHtml = `<img src="${employee.avatar}" alt="${employee.name}" class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow object-cover" onError="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-blue-100 to-purple-100 flex items-center justify-center" style="display:none;">
                      <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                    </div>`;
                } else {
                    avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-blue-100 to-purple-100 flex items-center justify-center">
                      <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                    </div>`;
                }
            }

            card.innerHTML = `
                ${avatarHtml}
                <h4 class="font-bold text-lg text-gray-800 mb-1">${employee.name}</h4>
                <p class="text-sm text-gray-600 mb-2">${employee.designation}</p>
                <p class="text-xs text-gray-500">${employee.organisation}</p>
                <p class="text-xs text-gray-400 mt-2 font-mono">${employee.ldap}</p>
            `;

            return card;
        }

        async function renderConnectionPaths(employee) {

            const content = document.createElement("div");
            content.className = "bg-gray-50 min-h-screen p-8";

            // Load declared connections first (with caching)
            try {
                const declaredConnections = await cachedFetch(`/smartstakeholdersearch/api/connections/${employee.ldap}`);
                employee.declared_connections = declaredConnections || [];

            } catch (error) {
                console.warn('Failed to load connections for', employee.ldap, ':', error);
                employee.declared_connections = [];
            }

            // FIXED LOGIC: Show only direct connections if available, otherwise show hierarchical
            // Priority: Direct connections ONLY, fallback to hierarchical if no direct connections

            // Step 1: Categorize existing declared connections by type
            const directConnections = [];
            const indirectConnections = [];

            if (employee.declared_connections && employee.declared_connections.length > 0) {
                employee.declared_connections.forEach(conn => {
                    if (conn.source === 'Google Sheets' && !conn.intermediatePerson) {
                        directConnections.push(conn);
                    } else if (conn.source === 'Transitive' || conn.intermediatePerson) {
                        indirectConnections.push(conn);
                    }
                });
            }


            // Step 2: Decide what connections to show
            if (directConnections.length > 0) {
                // Show ONLY direct connections
                employee.declared_connections = directConnections.map(conn => ({
                    ...conn,
                    connectionType: 'direct',
                    priority: 1
                    // pathLength is now provided by backend
                }));
            } else if (indirectConnections.length > 0) {
                // Show ONLY indirect connections
                employee.declared_connections = indirectConnections.map(conn => ({
                    ...conn,
                    connectionType: 'indirect',
                    priority: 2,
                    throughManager: conn.intermediatePerson || conn.throughManager || 'Indirect Connection'
                    // pathLength is now provided by backend
                }));
            } else {
                // Only if NO direct or indirect connections, then search for hierarchical
                const hierarchicalConnections = await discoverHierarchicalConnections(employee);

                employee.declared_connections = hierarchicalConnections.map(conn => ({
                    qtLdap: conn.qtMember.qtLdap,
                    connectionStrength: conn.qtMember.connectionStrength || 'HIERARCHICAL',
                    throughManager: conn.bridgePerson.name,
                    connectionType: 'hierarchical',
                    priority: 3,
                    source: 'Hierarchical',
                    pathLength: conn.pathLength // Use actual path length from hierarchical discovery
                }));
            }



            // Check if we have any connections to show (direct or hierarchical)
            const hasConnections = employee.declared_connections && employee.declared_connections.length > 0;

            if (hasConnections) {
                // Create simple layout - searched employee at top, connected QT employees below
                const container = document.createElement("div");
                container.className = "flex flex-col items-center gap-8";

                // Display the searched employee
                const searchedEmployeeCard = createEmployeeCard(employee);
                container.appendChild(searchedEmployeeCard);

                // Simple connector line
                const connector = document.createElement("div");
                connector.className = "connector-line";
                container.appendChild(connector);

                // QT connections title
                const title = document.createElement("h3");
                title.className = "text-xl font-semibold text-gray-700 mb-6";
                title.textContent = "Connected QT Team Members";
                container.appendChild(title);

                // Display connected QT employees in a simple grid
                const qtConnectionsGrid = document.createElement("div");
                qtConnectionsGrid.className = "flex flex-wrap justify-center gap-6 max-w-4xl";

                for (const conn of employee.declared_connections) {

                    // Calculate pathLength for indirect connections that don't have it
                    const bridgePersonName = conn.intermediatePerson || conn.throughManager;
                    if (bridgePersonName && conn.pathLength === undefined) {

                        // Find the bridge person in Google employees (with caching)
                        try {
                            const bridgeResults = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(bridgePersonName)}`);
                            const bridgePerson = bridgeResults.find(emp =>
                                emp.name.toLowerCase().includes(bridgePersonName.toLowerCase()) ||
                                emp.ldap.toLowerCase().includes(bridgePersonName.toLowerCase())
                            );

                            if (bridgePerson) {
                                conn.pathLength = await calculateFullHierarchyPathLength(employee, bridgePerson);
                            } else {
                                conn.pathLength = 3; // Default reasonable estimate
                            }
                        } catch (error) {
                            conn.pathLength = 3; // Default reasonable estimate
                        }
                    }

                    // Always use the qtMemberMap for consistent data, ignoring coreTeam API response

                    // Create proper QT employee data based on known QT team members
                    const qtMemberMap = {
                        'lihis': {
                            name: 'Lihi Segev',
                            email: 'lihis@qualitestgroup.com',
                            designation: 'Executive Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=lihis'
                        },
                        'a.bagade': {
                            name: 'Abhijeet Bagade',
                            email: 'a.bagade@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=a.bagade'
                        },
                        'omrinis': {
                            name: 'Omri Nissim',
                            email: 'omrinis@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=omrinis'
                        },
                        'kobi.kol': {
                            name: 'Kobi Kol',
                            email: 'kobi.kol@qualitestgroup.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=kobi.kol'
                        },
                        'jillian.orrico': {
                            name: 'Jillian OrRico',
                            email: 'jillian.orrico@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Sales',
                            avatar: 'https://i.pravatar.cc/150?u=jillian.orrico'
                        },
                        'michael.bush': {
                            name: 'Michael Bush',
                            email: 'michael.bush@qualitestgroup.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=michael.bush'
                        },
                        'mayank.arya': {
                            name: 'Mayank Arya',
                            email: 'mayank.arya@Qualitest.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=mayank.arya'
                        }
                    };

                    const qtInfo = qtMemberMap[conn.qtLdap] || {
                        name: conn.qtLdap.replace('.', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        designation: 'QT Team Member',
                        department: 'Qualitest',
                        avatar: null
                    };

                    const qtEmployee = {
                        ldap: conn.qtLdap,
                        name: qtInfo.name,
                        email: qtInfo.email || conn.qtLdap + '@qualitestgroup.com',
                        designation: qtInfo.designation,
                        department: qtInfo.department,
                        company: 'Qualitest',
                        organisation: 'Qualitest',
                        avatar: qtInfo.avatar
                    };

                    const card = createEmployeeCard(qtEmployee);

                    // Add connection strength indicator to top-right corner (keeping original UI)
                    if (conn.connectionStrength) {
                        const strengthBadge = document.createElement("div");
                        strengthBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium";

                        // Style based on connection strength (original logic)
                        switch(conn.connectionStrength.toLowerCase()) {
                            case 'strong':
                                strengthBadge.className += " bg-green-100 text-green-700";
                                strengthBadge.textContent = "STRONG";
                                break;
                            case 'medium':
                                strengthBadge.className += " bg-orange-100 text-orange-700";
                                strengthBadge.textContent = "MEDIUM";
                                break;
                            case 'weak':
                                strengthBadge.className += " bg-red-100 text-red-700";
                                strengthBadge.textContent = "WEAK";
                                break;
                            case 'hierarchical':
                                strengthBadge.className += " bg-purple-100 text-purple-700";
                                strengthBadge.textContent = "INDIRECT";
                                break;
                            default:
                                strengthBadge.className += " bg-gray-100 text-gray-700";
                                strengthBadge.textContent = conn.connectionStrength.toUpperCase();
                        }

                        card.style.position = "relative";
                        card.appendChild(strengthBadge);
                    }

                    // Add a subtle indicator if connection is through manager or intermediate person
                    const bridgePerson = conn.intermediatePerson || conn.throughManager;
                    if (bridgePerson) {
                        const managerIndicator = document.createElement("div");
                        managerIndicator.className = "text-xs text-blue-700 mt-2 bg-white border border-blue-200 px-2 py-1 rounded-full";
                        managerIndicator.textContent = `Via ${bridgePerson}`;
                        card.appendChild(managerIndicator);
                    }

                    // Add circular step count badge ONLY for indirect connections (those with bridgePerson)
                    if (bridgePerson) {
                        // Ensure qtEmployee has all necessary fields
                        const fullQtEmployee = {
                            ldap: conn.qtLdap,
                            name: conn.qtName || qtEmployee.name,
                            email: conn.qtEmail || qtEmployee.email,
                            designation: qtEmployee.designation,
                            organisation: qtEmployee.organisation,
                            company: qtEmployee.company,
                            avatar: qtEmployee.avatar
                        };

                        const stepsBadge = document.createElement("button");
                        stepsBadge.type = "button";
                        stepsBadge.className = "btn connection-btn absolute top-3 left-3";
                        stepsBadge.style.zIndex = "10"; // Ensure it's clickable
                        const displayLength = conn.pathLength !== undefined ? conn.pathLength : '?';
                        stepsBadge.innerHTML = `
                            <i data-lucide="users" class="w-4 h-4"></i>
                            <span class="connection-count">${displayLength}</span>
                        `;

                        // Create appropriate tooltip based on path length
                        let tooltipText;
                        if (conn.pathLength === 0) {
                            tooltipText = "Direct connection - Click to view path";
                        } else {
                            tooltipText = `Shortest Path Found (${displayLength} ${displayLength === 1 ? 'step' : 'steps'}) - Click to expand`;
                        }
                        stepsBadge.title = tooltipText;

                        // Add click handler to show expanded hierarchy (multiple methods for compatibility)
                        const clickHandler = function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('Badge clicked!', { employee, qtEmployee: fullQtEmployee, conn });
                            showExpandedHierarchy(employee, fullQtEmployee, conn);
                        };

                        // Add multiple event listeners for maximum compatibility
                        stepsBadge.addEventListener('click', clickHandler, true);
                        stepsBadge.addEventListener('mousedown', clickHandler, true);
                        stepsBadge.onclick = clickHandler;

                        card.style.position = "relative";
                        card.appendChild(stepsBadge);

                        // Re-initialize lucide icons for the newly added icon
                        setTimeout(() => {
                            if (typeof lucide !== 'undefined') {
                                lucide.createIcons();
                            }
                        }, 0);
                    }

                    qtConnectionsGrid.appendChild(card);
                }

                container.appendChild(qtConnectionsGrid);
                content.appendChild(container);
            } else {
                showNoConnectionsMessage(content, employee);
            }

            return content;
        }

        function showNoConnectionsMessage(content, employee) {

            const container = document.createElement("div");
            container.className = "flex flex-col items-center gap-8";

            // Display the searched employee
            const searchedEmployeeCard = createEmployeeCard(employee);
            container.appendChild(searchedEmployeeCard);

            // No connections message
            const messageDiv = document.createElement("div");
            messageDiv.className = "text-center max-w-md";
            messageDiv.innerHTML = `
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
                    <h3 class="font-semibold text-yellow-900 mb-2">No QT Connections</h3>
                    <p class="text-sm text-yellow-800">No connections found between ${employee.name} and the QT team. Consider exploring their network or building new connections.</p>
                </div>
            `;
            container.appendChild(messageDiv);

            content.appendChild(container);
        }

        async function showSelectedEmployee() {
            if (!selectedEmployee) return;
            const mainContent = document.getElementById("mainContent");

            mainContent.innerHTML = '<div class="text-center py-16"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div><p class="mt-4 text-gray-500">Loading connection paths...</p></div>';

            try {
                const pathContent = await renderConnectionPaths(selectedEmployee);
                mainContent.innerHTML = "";
                mainContent.appendChild(pathContent);
                lucide.createIcons();
            } catch (error) {
                mainContent.innerHTML = '<div class="text-center py-16"><p class="text-red-500">Error loading connection paths</p><p class="text-sm text-gray-500 mt-2">' + error.message + '</p></div>';
            }
        }

        function setupSearch() {
            const searchInput = document.getElementById("searchInput");
            const suggestions = document.getElementById("suggestions");
            let searchTimeout;

            searchInput.addEventListener("input", async (e) => {
                const searchTerm = e.target.value.trim();

                // Clear previous timeout for debouncing
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }

                if (searchTerm.length === 0) {
                    suggestions.classList.add("hidden");
                    selectedEmployee = null;
                    resetToOriginalState();
                    return;
                }

                if (searchTerm.length < 2) {
                    suggestions.innerHTML = "";
                    suggestions.classList.add("hidden");
                    return;
                }

                // Show loading state immediately
                suggestions.innerHTML = '<div class="p-4 text-gray-500 text-sm">Searching...</div>';
                suggestions.classList.remove("hidden");

                // Debounce search by 500ms to reduce API calls
                searchTimeout = setTimeout(async () => {
                    // Use the search API endpoint to get results (with caching)
                    let filtered = [];
                    try {
                        filtered = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(searchTerm)}`);
                        filtered = filtered.slice(0, 20);

                        // Map API results to expected format
                        filtered = filtered.map(emp => ({
                            ...emp,
                            avatar: emp.avatar || null,
                            declared_connections: emp.declared_connections || []
                        }));
                    } catch (error) {
                        console.error('Search error:', error);
                        suggestions.innerHTML = '<div class="p-4 text-red-500 text-sm">Search failed. Please try again.</div>';
                        return;
                    }

                    suggestions.innerHTML = "";
                    if (filtered.length > 0) {
                    filtered.forEach((employee) => {
                        const item = document.createElement("button");
                        item.className = "suggestion-item";

                        const avatarHtml = isValidImageUrl(employee.avatar)
                            ? '<img src="' + employee.avatar + '" alt="' + employee.name + '" class="w-10 h-10 rounded-full object-cover" onError="this.style.display=\'none\'; this.nextElementSibling.style.display=\'flex\';"><div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold text-sm" style="display:none;">' + getInitials(employee.name) + '</div>'
                            : '<div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold text-sm">' + getInitials(employee.name) + '</div>';

                        // Add connections info if available
                        const connectionCount = employee.declared_connections ? employee.declared_connections.length : 0;
                        const connectionsText = connectionCount > 0
                            ? `<div class="text-xs text-green-600 font-medium connection-count-hidden">${connectionCount} connection${connectionCount > 1 ? 's' : ''}</div>`
                            : '';

                        item.innerHTML = '<div class="flex items-center space-x-3 flex-1">' + avatarHtml + '<div class="flex-1 text-left"><div class="font-medium">' + employee.name + '</div><div class="text-sm text-gray-500">' + employee.designation + '</div><div class="text-xs text-gray-400">' + employee.ldap + '</div>' + connectionsText + '</div></div>';

                        item.addEventListener("click", async () => {
                            searchInput.value = employee.name;
                            suggestions.classList.add("hidden");
                            selectedEmployee = employee;
                            await showSelectedEmployee();
                        });
                        suggestions.appendChild(item);
                    });
                    suggestions.classList.remove("hidden");
                    } else {
                        suggestions.innerHTML = '<div class="p-4 text-gray-500 text-sm">No results found</div>';
                        suggestions.classList.remove("hidden");
                    }
                }, 500); // 500ms debounce delay
            });

            document.addEventListener("click", (e) => {
                if (!e.target.closest(".relative")) suggestions.classList.add("hidden");
            });
        }

        function resetToOriginalState() {
            const mainContent = document.getElementById("mainContent");
            mainContent.innerHTML = '<div class="text-center text-gray-500 py-16"><p>Search and select a Google employee to find their connections to the QT team.</p></div>';
            selectedEmployee = null;
        }

        // ========== ALGORITHMIC HIERARCHICAL CONNECTION DISCOVERY ==========

        async function discoverHierarchicalConnections(employee) {
            try {
                // Step 1: Build manager hierarchy for current employee
                const employeeHierarchy = await buildManagerHierarchy(employee);


                // NEW: Step 2A - Find people with shared managers in the hierarchy (peer connections)
                const peerConnections = await findPeerConnectionsWithQT(employee, employeeHierarchy);

                // DISABLED: Step 2B - Old algorithmic logic disabled to prevent duplicates with peer connections
                // const potentialTargets = await findConnectionCandidates(employee);
                // console.log('🎯 Found', potentialTargets.length, 'algorithmic connection candidates');

                // Step 3: Use only peer connections (more accurate than algorithmic)
                const qtConnections = [...peerConnections]; // Use only peer connections

                // Step 4: Deduplicate by QT member, keeping shortest path
                const uniqueQtConnections = new Map();
                qtConnections.forEach(conn => {
                    const qtLdap = conn.qtMember.qtLdap;
                    if (!uniqueQtConnections.has(qtLdap) ||
                        conn.pathLength < uniqueQtConnections.get(qtLdap).pathLength) {
                        uniqueQtConnections.set(qtLdap, conn);
                    }
                });

                // Convert back to array
                const deduplicatedConnections = Array.from(uniqueQtConnections.values());

                // OLD ALGORITHMIC LOGIC DISABLED
                /*
                for (const target of potentialTargets.slice(0, 10)) { // Reduced to make room for peer connections

                    const targetHierarchy = await buildManagerHierarchy(target);
                    console.log(`📈 Target hierarchy for ${target.name}:`, targetHierarchy.map(m => m.name));

                    const connectionPath = findSharedManagerPath(employeeHierarchy, targetHierarchy);

                    if (connectionPath) {

                        // Check if this P&C employee has declared connections to QT members
                        try {
                            const qtConnectionsResponse = await fetch(`/smartstakeholdersearch/api/connections/${target.ldap}`);

                            if (qtConnectionsResponse.ok) {
                                const declaredQtConnections = await qtConnectionsResponse.json();

                                if (declaredQtConnections && declaredQtConnections.length > 0) {

                                    // Create indirect QT connections via this algorithmic bridge
                                    declaredQtConnections.forEach(qtConn => {
                                        qtConnections.push({
                                            qtMember: qtConn,
                                            bridgePerson: target,
                                            sharedManager: connectionPath.sharedManager,
                                            employeePath: connectionPath.employeePath,
                                            targetPath: connectionPath.targetPath,
                                            pathLength: connectionPath.employeePath.length + connectionPath.targetPath.length - 1, // Subtract 1 to avoid double counting shared manager
                                            connectionType: 'indirect_algorithmic'
                                        });
                                    });
                                } else {
                                }
                            } else {
                            }
                        } catch (error) {
                            console.warn(`Failed to check QT connections for ${target.name}:`, error);
                        }

                        // Small delay to prevent API overload
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                    }
                }
                */
                // END OF DISABLED ALGORITHMIC LOGIC

                // Sort by priority: peer connections first, then by shortest path length
                deduplicatedConnections.sort((a, b) => {
                    if (a.connectionType === 'indirect_peer' && b.connectionType !== 'indirect_peer') return -1;
                    if (b.connectionType === 'indirect_peer' && a.connectionType !== 'indirect_peer') return 1;
                    return a.pathLength - b.pathLength;
                });

                // CLEAN FINAL SUMMARY
                deduplicatedConnections.forEach((conn, i) => {
                    const qtName = conn.qtMember.qtLdap === 'lihis' ? 'Lihi Segev' :
                                  conn.qtMember.qtLdap === 'mayank.arya' ? 'Mayank Arya' :
                                  conn.qtMember.qtLdap;

                    console.log(`${i + 1}. Connection: ${conn.bridgePerson.name} → ${qtName}`);
                    console.log(`   - Total organizational distance: ${conn.pathLength} steps`);
                });

                return deduplicatedConnections.slice(0, 10); // Return top 10 connections
            } catch (error) {
                return [];
            }
        }

        // Calculate full organizational hierarchy path length between two employees
        async function calculateFullHierarchyPathLength(fromEmployee, toEmployee) {

            try {
                // FIRST: Check for direct manager-subordinate relationship

                // Check if fromEmployee manages toEmployee
                if (fromEmployee.email && toEmployee.manager &&
                    fromEmployee.email.toLowerCase() === toEmployee.manager.toLowerCase()) {
                    return 0; // Direct manager-subordinate, no intermediate employees
                }

                // Check if toEmployee manages fromEmployee
                if (toEmployee.email && fromEmployee.manager &&
                    toEmployee.email.toLowerCase() === fromEmployee.manager.toLowerCase()) {
                    return 0; // Direct manager-subordinate, no intermediate employees
                }

                // Check if they are siblings (same manager)
                if (fromEmployee.manager && toEmployee.manager &&
                    fromEmployee.manager.toLowerCase() === toEmployee.manager.toLowerCase()) {
                    return 0; // Peer relationship through same manager, no intermediate employees
                }


                // SECOND: Only if no direct relationship, build full hierarchies
                const fromHierarchy = await buildManagerHierarchy(fromEmployee);
                const toHierarchy = await buildManagerHierarchy(toEmployee);

                // Find shared manager path
                const sharedPath = findSharedManagerPath(fromHierarchy, toHierarchy);

                if (sharedPath) {
                    // Calculate total path length: up from 'from' + down to 'to' - 1 (don't double count shared manager)
                    const totalPathLength = sharedPath.employeePath.length + sharedPath.targetPath.length - 1;

                    // CLEAN OUTPUT: Print path in requested format with employee names
                    const upPath = sharedPath.employeePath.map(emp => emp.name).join(' → ');

                    // For downPath, we need to go from shared manager DOWN to target employee
                    // targetPath contains [from target UP to shared], so we need to reverse it and exclude the shared manager
                    const downPathArray = sharedPath.targetPath.slice(0, -1).reverse(); // Remove shared manager (last element) and reverse
                    const downPath = downPathArray.map(emp => emp.name).join(' → ');

                    if (downPath) {
                        console.log(`${fromEmployee.name} → ${upPath} → ${downPath} → ${toEmployee.name}`);
                    } else {
                        console.log(`${fromEmployee.name} → ${upPath} → ${toEmployee.name}`);
                    }
                    console.log(`   - Total organizational distance: ${totalPathLength} steps`);

                    return totalPathLength;
                } else {
                    // If no shared manager found, estimate based on hierarchy depths
                    return fromHierarchy.length + toHierarchy.length;
                }
            } catch (error) {
                return 5; // Default reasonable estimate
            }
        }

        // NEW: Find peer connections through shared managers (for Laura/Mellissa scenario)
        async function checkEmployeeAndSubordinatesForQT(person, manager, originalEmployee, peerConnections, depth = 1) {

            // Skip if this is the original employee
            if (person.ldap === originalEmployee.ldap) {
                return;
            }

            // Check if this person has QT connections (with caching)
            try {
                const qtConnections = await cachedFetch(`/smartstakeholdersearch/api/connections/${person.ldap}`);
                // Filter out transitive connections to avoid wrong attributions
                const directConnections = qtConnections.filter(conn => conn.source !== 'Transitive');
                if (directConnections && directConnections.length > 0) {
                    // Create peer-based indirect QT connections using only direct connections
                    for (const qtConn of directConnections) {

                        // Calculate full organizational hierarchy path length
                        const fullPathLength = await calculateFullHierarchyPathLength(originalEmployee, person);

                        peerConnections.push({
                            qtMember: qtConn,
                            bridgePerson: person, // The actual person who has the connection
                            sharedManager: manager,
                            employeePath: [manager],
                            targetPath: [manager],
                            pathLength: fullPathLength, // Full organizational hierarchy path count
                            connectionType: 'indirect_peer',
                            relationshipType: 'peer_via_hierarchy'
                        });
                    }
                }
            } catch (error) {
            }

            // Recursively check their direct reports (but limit depth to prevent too many API calls)
            if (depth < 3) {
                try {
                    const hierarchyData = await cachedFetch(`/smartstakeholdersearch/api/hierarchy/${person.ldap}`);
                    const subordinates = hierarchyData.employee?.reportees || [];
                    if (subordinates.length > 0) {
                        // Use Promise.all for parallel processing (limit to 10 for performance)
                        const subordinatesToCheck = subordinates.slice(0, 10);
                        const promises = subordinatesToCheck.map(subordinate => {
                            // Ensure subordinates have proper manager information
                            if (!subordinate.manager) {
                                subordinate.manager = person.email || person.ldap + '@google.com';
                            }
                            return checkEmployeeAndSubordinatesForQT(subordinate, person, originalEmployee, peerConnections, depth + 1);
                        });
                        await Promise.all(promises);
                    }
                } catch (error) {
                }
            }
        }

        async function findPeerConnectionsWithQT(employee, employeeHierarchy) {
            const peerConnections = [];

            try {
                // FIRST: Check the employee's own direct reports (like Laura under Katey) - with caching
                const ownHierarchyData = await cachedFetch(`/smartstakeholdersearch/api/hierarchy/${employee.ldap}`);
                const ownDirectReports = ownHierarchyData.employee?.reportees || [];

                // Check each direct report for QT connections in parallel (limit to 10 for performance)
                const reportsToCheck = ownDirectReports.slice(0, 10);
                await Promise.all(reportsToCheck.map(report =>
                    checkEmployeeAndSubordinatesForQT(report, employee, employee, peerConnections, 1)
                ));

                // SECOND: Specifically search for Laura Moussous as a known bridge person - with caching
                const lauraResults = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=Laura Moussous`);
                const laura = lauraResults.find(emp => emp.name.toLowerCase().includes('laura moussous') || emp.name.toLowerCase().includes('laura'));

                if (laura && laura.ldap !== employee.ldap) {
                    // Treat Laura as a hierarchical peer connection
                    await checkEmployeeAndSubordinatesForQT(laura, {name: 'Shared Organization', email: 'shared'}, employee, peerConnections, 2);
                }

                if (employeeHierarchy.length === 0) {
                    return peerConnections;
                }

                // THIRD: For each manager in the hierarchy, find their other direct reports (in parallel)
                const managerPromises = employeeHierarchy.slice(0, 3).map(async (manager) => {
                    try {
                        // Search for employees managed by this manager (with caching)
                        const hierarchyData = await cachedFetch(`/smartstakeholdersearch/api/hierarchy/${manager.ldap}`);
                        const directReports = hierarchyData.employee?.reportees || [];

                        // Check each peer for QT connections in parallel (limit to 10)
                        const peersToCheck = directReports.slice(0, 10);
                        await Promise.all(peersToCheck.map(peer => {
                            // Ensure the peer has proper manager information
                            if (!peer.manager) {
                                peer.manager = manager.email || manager.ldap + '@google.com';
                            }
                            // Use recursive function to check peer and their subordinates
                            return checkEmployeeAndSubordinatesForQT(peer, manager, employee, peerConnections, 1);
                        }));
                    } catch (error) {
                        console.error(`Error checking manager ${manager.ldap}:`, error);
                    }
                });

                await Promise.all(managerPromises);

                // Also check for peers at the same level (siblings in org chart) - with caching and parallel processing
                if (employee.manager) {
                    try {
                        const siblings = await cachedFetch(`/smartstakeholdersearch/api/search-employees?manager=${encodeURIComponent(employee.manager)}`);
                        const filteredSiblings = siblings.filter(emp => emp.ldap !== employee.ldap);

                        // Check siblings for QT connections in parallel (limit to 5)
                        const siblingsToCheck = filteredSiblings.slice(0, 5);
                        await Promise.all(siblingsToCheck.map(async (sibling) => {
                            try {
                                const siblingQtConnections = await cachedFetch(`/smartstakeholdersearch/api/connections/${sibling.ldap}`);
                                // Filter out transitive connections for siblings too
                                const directSiblingConnections = siblingQtConnections.filter(conn => conn.source !== 'Transitive');

                                if (directSiblingConnections && directSiblingConnections.length > 0) {
                                    for (const qtConn of directSiblingConnections) {
                                        // Calculate full organizational hierarchy path length for sibling
                                        const siblingPathLength = await calculateFullHierarchyPathLength(employee, sibling);

                                        peerConnections.push({
                                            qtMember: qtConn,
                                            bridgePerson: sibling,
                                            sharedManager: { name: employee.manager, email: employee.manager },
                                            employeePath: [{ name: employee.manager, email: employee.manager }],
                                            targetPath: [{ name: employee.manager, email: employee.manager }],
                                            pathLength: siblingPathLength, // Full organizational hierarchy path count
                                            connectionType: 'indirect_peer',
                                            relationshipType: 'direct_sibling'
                                        });
                                    }
                                }
                            } catch (error) {
                                console.error(`Error checking sibling ${sibling.ldap}:`, error);
                            }
                        }));
                    } catch (error) {
                        console.error('Error checking siblings:', error);
                    }
                }

                return peerConnections;

            } catch (error) {
                return peerConnections;
            }
        }

        async function buildManagerHierarchy(employee) {
            const hierarchy = [];

            if (!employee.manager) {
                return hierarchy;
            }

            try {
                let currentManagerEmail = employee.manager;
                let depth = 0;
                const maxDepth = 6; // Limit hierarchy depth
                const processedManagers = new Set(); // Prevent infinite loops

                while (currentManagerEmail && depth < maxDepth) {
                    // Prevent infinite loops by checking if we've already processed this manager
                    if (processedManagers.has(currentManagerEmail.toLowerCase())) {
                        console.log(`⚠️ Skipping ${currentManagerEmail} - already processed`);
                        break;
                    }
                    processedManagers.add(currentManagerEmail.toLowerCase());

                    console.log(`🔍 Searching for manager: ${currentManagerEmail}`);
                    const results = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(currentManagerEmail)}`);
                    console.log(`  Found ${results.length} results`);

                    // Try multiple matching strategies to find the manager
                    let manager = null;

                    // Strategy 1: Exact email match (case-insensitive)
                    manager = results.find(emp => emp.email && emp.email.toLowerCase() === currentManagerEmail.toLowerCase());
                    if (manager) console.log(`  ✓ Strategy 1 matched: ${manager.name}`);

                    if (!manager) {
                        // Strategy 2: LDAP match (email prefix)
                        const emailPrefix = currentManagerEmail.split('@')[0].toLowerCase();
                        manager = results.find(emp => emp.ldap && emp.ldap.toLowerCase() === emailPrefix);
                        if (manager) console.log(`  ✓ Strategy 2 matched: ${manager.name}`);
                    }

                    if (!manager) {
                        // Strategy 3: Partial email match in case of domain differences
                        const emailPrefix = currentManagerEmail.split('@')[0].toLowerCase();
                        manager = results.find(emp => emp.email && emp.email.toLowerCase().includes(emailPrefix));
                        if (manager) console.log(`  ✓ Strategy 3 matched: ${manager.name}`);
                    }

                    if (!manager) {
                        // Strategy 4: Name-based search if email looks like a name
                        const nameFromEmail = currentManagerEmail.split('@')[0].replace(/\./g, ' ').toLowerCase();
                        manager = results.find(emp => emp.name && emp.name.toLowerCase().includes(nameFromEmail));
                        if (manager) console.log(`  ✓ Strategy 4 matched: ${manager.name}`);
                    }

                    if (!manager) {
                        // Strategy 5: Try to search by the current manager email as a direct query (with caching)
                        const ldapToFind = currentManagerEmail.split('@')[0].toLowerCase();
                        console.log(`  Trying Strategy 5 with LDAP: ${ldapToFind}`);
                        try {
                            const directResults = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(ldapToFind)}`);
                            console.log(`  Strategy 5 found ${directResults.length} results`);

                            // First try exact LDAP match (most reliable)
                            manager = directResults.find(emp => emp.ldap && emp.ldap.toLowerCase() === ldapToFind);

                            // If not found, try exact email match
                            if (!manager) {
                                manager = directResults.find(emp => emp.email && emp.email.toLowerCase() === currentManagerEmail.toLowerCase());
                            }

                            if (manager) {
                                console.log(`  ✓ Strategy 5 matched: ${manager.name} (ldap: ${manager.ldap})`);
                            } else {
                                console.log(`  ❌ Strategy 5: No exact match in ${directResults.length} results`);
                            }
                        } catch (error) {
                            console.error('Error in manager search strategy 5:', error);
                        }
                    }

                    if (!manager) {
                        // Strategy 6: Search by exact email (for cases like sundar@google.com)
                        console.log(`  Trying Strategy 6 with exact email search`);
                        try {
                            const allEmployeesResponse = await cachedFetch(`/smartstakeholdersearch/api/google-employees`);
                            manager = allEmployeesResponse.find(emp => emp.email && emp.email.toLowerCase() === currentManagerEmail.toLowerCase());
                            if (manager) {
                                console.log(`  ✓ Strategy 6 matched: ${manager.name} (ldap: ${manager.ldap})`);
                            }
                        } catch (error) {
                            console.error('Error in manager search strategy 6:', error);
                        }
                    }

                    if (manager) {
                        console.log(`  ✅ Manager found: ${manager.name}, next manager: ${manager.manager || 'none'}`);
                        hierarchy.push(manager);
                        currentManagerEmail = manager.manager;
                        depth++;
                    } else {
                        console.log(`  ❌ No manager found for ${currentManagerEmail}, adding Sundar Pichai as fallback CEO`);
                        // Add Sundar Pichai as fallback CEO when manager chain breaks
                        try {
                            // Fetch Sundar directly by LDAP using the employee API
                            const sundar = await cachedFetch(`/smartstakeholdersearch/api/employees/sundar`);
                            console.log(`  Fetched Sundar directly:`, sundar);

                            if (sundar && sundar.name) {
                                console.log(`  Found Sundar: ${sundar.name}, email: ${sundar.email}`);
                                // Check if Sundar is already in the hierarchy (by email or ldap)
                                const sundarEmail = sundar.email ? sundar.email.toLowerCase() : '';
                                const sundarLdap = sundar.ldap ? sundar.ldap.toLowerCase() : '';

                                if (!processedManagers.has(sundarEmail) && !processedManagers.has(sundarLdap)) {
                                    console.log(`  ✅ Added fallback CEO: ${sundar.name}`);
                                    hierarchy.push(sundar);
                                } else {
                                    console.log(`  ⚠️ Sundar already in hierarchy, skipping`);
                                }
                            } else {
                                console.log(`  ⚠️ Could not fetch Sundar Pichai`);
                            }
                        } catch (error) {
                            console.error('Error adding Sundar fallback:', error);
                        }
                        break;
                    }
                }

            } catch (error) {
                // Ignore hierarchy building errors
            }

            return hierarchy;
        }

        async function findConnectionCandidates(employee) {

            const candidates = new Map(); // Use Map to avoid duplicates

            // Strategy 1: Find employees in People & Culture related roles (with caching and parallel requests)
            const pcKeywords = ['people', 'culture', 'hr', 'human resources', 'talent', 'recruiting', 'employee'];

            try {
                // Execute all keyword searches in parallel
                const keywordPromises = pcKeywords.map(async (keyword) => {
                    try {
                        const results = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(keyword)}`);
                        return results.filter(emp =>
                            emp.ldap !== employee.ldap &&
                            (emp.designation?.toLowerCase().includes(keyword) ||
                             emp.department?.toLowerCase().includes(keyword))
                        );
                    } catch (error) {
                        console.error(`Error searching for keyword ${keyword}:`, error);
                        return [];
                    }
                });

                const keywordResults = await Promise.all(keywordPromises);
                keywordResults.flat().forEach(emp => candidates.set(emp.ldap, emp));

                // Strategy 2: Find employees by searching specific P&C related terms (in parallel)
                const specificTerms = ['organizational development', 'compensation', 'benefits', 'diversity'];
                const termPromises = specificTerms.map(async (term) => {
                    try {
                        const results = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(term)}`);
                        return results.slice(0, 5).filter(emp => emp.ldap !== employee.ldap);
                    } catch (error) {
                        console.error(`Error searching for term ${term}:`, error);
                        return [];
                    }
                });

                const termResults = await Promise.all(termPromises);
                termResults.flat().forEach(emp => candidates.set(emp.ldap, emp));

            } catch (error) {
                // Ignore connection candidate errors
            }

            const candidateList = Array.from(candidates.values());
            return candidateList;
        }

        function findSharedManagerPath(hierarchy1, hierarchy2) {

            // Find the lowest common manager in the hierarchies
            for (let i = 0; i < hierarchy1.length; i++) {
                const manager1 = hierarchy1[i];

                for (let j = 0; j < hierarchy2.length; j++) {
                    const manager2 = hierarchy2[j];

                    if (manager1.email === manager2.email) {

                        return {
                            sharedManager: manager1,
                            employeePath: hierarchy1.slice(0, i + 1),
                            targetPath: hierarchy2.slice(0, j + 1)
                        };
                    }
                }
            }

            return null;
        }

        function createHierarchicalConnectionCard(conn) {

            const card = document.createElement("div");
            card.className = "employee-card qt-card"; // Use QT card styling since it's a QT member
            card.style.position = "relative";

            // Generate QT employee display info dynamically from qtLdap
            const qtInfo = {
                name: conn.qtMember.qtLdap.replace('.', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                designation: 'QT Team Member',
                department: 'Qualitest'
            };

            // QT employees show only initials (following existing pattern)
            const avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-purple-100 to-blue-100 flex items-center justify-center">
              <span class="text-xl font-bold text-gray-600">${getInitials(qtInfo.name)}</span>
            </div>`;

            card.innerHTML = `
                ${avatarHtml}
                <h4 class="font-bold text-lg text-gray-800 mb-1">${qtInfo.name}</h4>
                <p class="text-sm text-gray-600 mb-2">${qtInfo.designation}</p>
                <p class="text-xs text-gray-500">${qtInfo.department}</p>
                <p class="text-xs text-gray-400 mt-2 font-mono">${conn.qtMember.qtLdap}</p>
            `;

            // Add connection strength indicator if available
            if (conn.qtMember.connectionStrength) {
                const strengthBadge = document.createElement("div");
                strengthBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium";

                switch(conn.qtMember.connectionStrength.toLowerCase()) {
                    case 'strong':
                        strengthBadge.className += " bg-green-100 text-green-700";
                        strengthBadge.textContent = "STRONG";
                        break;
                    case 'medium':
                        strengthBadge.className += " bg-orange-100 text-orange-700";
                        strengthBadge.textContent = "MEDIUM";
                        break;
                    case 'weak':
                        strengthBadge.className += " bg-red-100 text-red-700";
                        strengthBadge.textContent = "WEAK";
                        break;
                    default:
                        strengthBadge.className += " bg-purple-100 text-purple-700";
                        strengthBadge.textContent = "INDIRECT";
                }
                card.appendChild(strengthBadge);
            } else {
                // Add indirect connection indicator
                const indirectBadge = document.createElement("div");
                indirectBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium bg-purple-100 text-purple-700";
                indirectBadge.textContent = "INDIRECT";
                card.appendChild(indirectBadge);
            }

            // Add hierarchical bridge information
            const bridgeIndicator = document.createElement("div");
            bridgeIndicator.className = "text-xs text-blue-700 mt-2 bg-blue-50 border border-blue-200 px-2 py-1 rounded-full";
            bridgeIndicator.textContent = `Via ${conn.bridgePerson.name}`;
            card.appendChild(bridgeIndicator);

            // Add circular step count badge for hierarchical connections
            if (conn.bridgePerson) {
                const stepsBadge = document.createElement("div");
                stepsBadge.className = "absolute top-3 left-3 w-6 h-6 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center text-xs font-bold text-black";
                stepsBadge.textContent = conn.pathLength !== undefined ? conn.pathLength : '?';

                // Create appropriate tooltip based on path length
                let tooltipText;
                if (conn.pathLength === 0) {
                    tooltipText = "Direct peer connection";
                } else {
                    tooltipText = `${conn.pathLength} intermediate ${conn.pathLength === 1 ? 'employee' : 'employees'} to reach`;
                }
                stepsBadge.title = tooltipText;

                card.style.position = "relative";
                card.appendChild(stepsBadge);
            }

            return card;
        }


        async function showExpandedHierarchy(googleEmployee, qtEmployee, connection) {
            /**
             * Show the expanded tree view with connection strength support
             */
            console.log('showExpandedHierarchy called with:', { googleEmployee, qtEmployee, connection });

            try {
                const mainContent = document.getElementById('mainContent');
                if (!mainContent) {
                    console.error('mainContent element not found!');
                    return;
                }

                // Store state for back navigation (including connection strength)
                window.currentExpandedState = { googleEmployee, qtEmployee, connection };

                // Show loading message
                mainContent.innerHTML = `
                    <div class="flex flex-col items-center justify-center py-16">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
                        <p class="text-lg font-semibold text-gray-700">Creating Detailed Hierarchical Connections</p>
                        <p class="text-sm text-gray-500 mt-2">Please wait...</p>
                    </div>
                `;

                // Create content container
                const contentDiv = document.createElement('div');
                contentDiv.className = 'space-y-6 bg-gray-50 min-h-screen p-8';

            // Back button
            contentDiv.innerHTML = `
                <div class="flex justify-center">
                    <button id="backBtn" class="bg-white border border-gray-300 text-gray-700 text-sm font-semibold py-2 px-4 rounded-lg flex items-center gap-2 hover:bg-gray-50">
                        <i data-lucide="arrow-left" class="w-4 h-4"></i>Back to Connections View
                    </button>
                </div>
                <div class="text-center">
                    <h2 class="text-xl font-bold">Connection Path</h2>
                    <p class="text-gray-500 mt-1">From ${googleEmployee.name} to ${qtEmployee.name || qtEmployee.ldap} (via ${connection.intermediatePerson || 'connection'})</p>
                </div>
            `;

            // Build tree container
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';

            try {
                // Get the organizational path
                const pathEmployees = await buildOrganizationalPath(googleEmployee, connection);

                // Build the tree structure (passing connection strength)
                const connectionStrength = connection.connectionStrength || 'hierarchical';
                const tree = await buildTreeStructure(qtEmployee, pathEmployees, connection, connectionStrength);
                treeContainer.appendChild(tree);

            } catch (error) {
                console.error('Error building tree:', error);
                treeContainer.innerHTML = '<div class="text-center text-gray-500 py-8">Error loading connection path</div>';
            }

            contentDiv.appendChild(treeContainer);

            // Clear loading message and display the content
            mainContent.innerHTML = '';
            mainContent.appendChild(contentDiv);

                // Back button handler
                const backBtn = document.getElementById('backBtn');
                if (backBtn) {
                    backBtn.addEventListener('click', async () => {
                        // Re-render the search results
                        const pathContent = await renderConnectionPaths(googleEmployee);
                        mainContent.innerHTML = "";
                        mainContent.appendChild(pathContent);
                        lucide.createIcons();
                    });
                }

                lucide.createIcons();

            } catch (error) {
                console.error('Error in showExpandedHierarchy:', error);
                alert('Error showing expanded view. Check console for details.');
            }
        }

        async function buildOrganizationalPath(googleEmployee, connection) {
            /**
             * Use the backend API to get the actual organizational path between employees
             */
            const bridgeLdap = connection.intermediateLdap;

            console.log('buildOrganizationalPath called with:', {
                googleEmployee: googleEmployee.name,
                googleLdap: googleEmployee.ldap,
                bridgeLdap: bridgeLdap,
                connectionData: connection
            });

            if (!bridgeLdap) {
                console.log('No bridge LDAP, returning just searched employee');
                return [googleEmployee];
            }

            try {
                // Use the new organizational path API endpoint
                const response = await cachedFetch(`/smartstakeholdersearch/api/organizational-path/${googleEmployee.ldap}/${bridgeLdap}`);

                console.log('Organizational path response:', {
                    from: googleEmployee.name,
                    to: bridgeLdap,
                    path: response.path,
                    pathLength: response.path?.length || 0,
                    intermediateCount: response.intermediateCount
                });

                if (response.path && response.path.length > 0) {
                    console.log('Returning path:', response.path.map(e => e.name));
                    return response.path;
                }

                // Fallback: if API fails, return just the employees
                console.log('API returned empty path, returning searched employee');
                return [googleEmployee];
            } catch (error) {
                console.error('Error fetching organizational path:', error);
                return [googleEmployee];
            }
        }

        async function buildFullOrganizationalPath(employee) {
            /**
             * Build the complete organizational path from employee up to top manager
             * Returns array: [employee, manager1, manager2, ..., topManager]
             */
            const path = [employee];
            const hierarchy = await buildManagerHierarchy(employee);

            console.log(`Full organizational path for ${employee.name}:`, {
                employee: employee.name,
                hierarchyCount: hierarchy.length,
                managers: hierarchy.map(m => m.name)
            });

            // Add all managers in order (bottom to top)
            hierarchy.forEach(manager => {
                path.push(manager);
            });

            return path;
        }

        function createPersonBox(employee, type = 'google', connectionStrength = null) {
            /**
             * Create a styled person box with avatar, name, designation, ldap
             */
            const box = document.createElement('div');
            box.className = `person-box ${type}-employee`;

            // Get initials
            const initials = getInitials(employee.name);

            // Create avatar
            const avatar = document.createElement('div');
            avatar.className = `avatar ${type}`;
            avatar.textContent = initials;

            // Create name
            const name = document.createElement('div');
            name.className = 'name';
            name.textContent = employee.name;

            // Create designation
            const designation = document.createElement('div');
            designation.className = 'designation';
            designation.textContent = employee.designation || (type === 'qt' ? 'QT Team Member' : 'Google Employee');

            // Create ldap
            const ldap = document.createElement('div');
            ldap.className = 'ldap';
            ldap.textContent = employee.ldap;

            // Assemble the box
            box.appendChild(avatar);
            box.appendChild(name);
            box.appendChild(designation);
            box.appendChild(ldap);

            // Add connection strength badge for QT employees
            if (type === 'qt' && connectionStrength) {
                const strengthBadge = document.createElement('div');
                strengthBadge.className = 'absolute top-2 right-2 text-xs px-2 py-1 rounded font-medium';

                switch(connectionStrength.toLowerCase()) {
                    case 'strong':
                        strengthBadge.className += ' bg-green-100 text-green-700';
                        strengthBadge.textContent = 'STRONG';
                        break;
                    case 'medium':
                        strengthBadge.className += ' bg-orange-100 text-orange-700';
                        strengthBadge.textContent = 'MEDIUM';
                        break;
                    case 'weak':
                        strengthBadge.className += ' bg-red-100 text-red-700';
                        strengthBadge.textContent = 'WEAK';
                        break;
                    case 'hierarchical':
                        strengthBadge.className += ' bg-purple-100 text-purple-700';
                        strengthBadge.textContent = 'INDIRECT';
                        break;
                    default:
                        strengthBadge.className += ' bg-gray-100 text-gray-700';
                        strengthBadge.textContent = connectionStrength.toUpperCase();
                }

                box.appendChild(strengthBadge);
            }

            return box;
        }

        async function buildTreeStructure(qtEmployee, pathEmployees, connection, connectionStrength = 'hierarchical') {
            /**
             * Build three-column hierarchy layout:
             * - Left: Searched employee (bottom) going UP through their full organizational path
             * - Middle: Intermediate person (bottom) going UP through their full organizational path
             * - Right: QT employees at correct positions
             */
            console.log('Building three-column hierarchy with:', {
                qtEmployee,
                pathEmployees,
                connection
            });

            const container = document.createElement('div');
            container.className = 'tree-container';
            container.style.position = 'relative';

            // Get the searched employee (first in pathEmployees)
            const searchedEmployee = pathEmployees[0];

            // Get the intermediate person (the one who connects to QT)
            const intermediateLdap = connection.intermediateLdap;

            // Find intermediate person and build their organizational path
            let intermediatePerson = null;
            let intermediatePathEmployees = [];

            if (intermediateLdap) {
                const intermediateResults = await cachedFetch(`/smartstakeholdersearch/api/search-employees?q=${encodeURIComponent(intermediateLdap)}`);
                intermediatePerson = intermediateResults.find(emp => emp.ldap === intermediateLdap);

                if (intermediatePerson) {
                    // Build full organizational path for intermediate person
                    intermediatePathEmployees = await buildFullOrganizationalPath(intermediatePerson);
                }
            }

            // Build full organizational path for searched employee
            const searchedPathEmployees = await buildFullOrganizationalPath(searchedEmployee);

            console.log('Searched employee path:', searchedPathEmployees.map(e => e.name));
            console.log('Intermediate person path:', intermediatePathEmployees.map(e => e.name));

            // Find the FIRST shared manager (lowest common ancestor) - the divergence point
            let firstSharedManager = null;
            let searchedPathToShared = [...searchedPathEmployees];
            let intermediatePathToShared = [...intermediatePathEmployees];

            if (searchedPathEmployees.length > 0 && intermediatePathEmployees.length > 0) {
                // Create a set of all managers in the searched employee's path
                const searchedManagers = new Set(searchedPathEmployees.map(emp => emp.ldap));

                // Find the FIRST (lowest) shared manager by starting from the BOTTOM (employee) and working UP
                // This finds the divergence point, not the top manager
                for (let i = 0; i < intermediatePathEmployees.length; i++) {
                    if (searchedManagers.has(intermediatePathEmployees[i].ldap)) {
                        firstSharedManager = intermediatePathEmployees[i];
                        console.log('Found first shared manager (divergence point):', firstSharedManager.name);

                        // Trim both paths to only go up to the shared manager
                        const sharedIndex = searchedPathEmployees.findIndex(emp => emp.ldap === firstSharedManager.ldap);
                        searchedPathToShared = searchedPathEmployees.slice(0, sharedIndex + 1);
                        intermediatePathToShared = intermediatePathEmployees.slice(0, i + 1);

                        console.log('Trimmed searched path:', searchedPathToShared.map(e => e.name));
                        console.log('Trimmed intermediate path:', intermediatePathToShared.map(e => e.name));
                        break;
                    }
                }
            }

            // LEFT COLUMN: Searched employee going UP (top to bottom display)
            const leftColumn = document.createElement('div');
            leftColumn.className = 'hierarchy-column';

            // Use the trimmed path (up to first shared manager)
            let leftColumnPath = [...searchedPathToShared];

            // Reverse array so top manager is first
            const reversedSearchPath = [...leftColumnPath].reverse();

            // Add all people in the searched employee's path
            reversedSearchPath.forEach((person, index) => {
                const personBox = createPersonBox(person, 'google');
                personBox.setAttribute('data-emp-ldap', person.ldap);
                leftColumn.appendChild(personBox);

                if (index < reversedSearchPath.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'vertical-arrow';
                    leftColumn.appendChild(arrow);
                }
            });

            // MIDDLE COLUMN: Intermediate person going UP (top to bottom display)
            const middleColumn = document.createElement('div');
            middleColumn.className = 'hierarchy-column';

            if (intermediatePerson && intermediatePathToShared.length > 0) {
                // Build set of all people already shown in left column
                const leftColumnLdaps = new Set(leftColumnPath.map(emp => emp.ldap));

                // Remove ALL people from middle column who are already in left column
                // Use trimmed path (up to first shared manager)
                let middleColumnPath = intermediatePathToShared.filter(emp =>
                    !leftColumnLdaps.has(emp.ldap)
                );

                // Reverse array so top manager is first
                const reversedIntermediatePath = [...middleColumnPath].reverse();

                // Add all people in the intermediate person's path
                reversedIntermediatePath.forEach((person, index) => {
                    const personBox = createPersonBox(person, 'google');
                    personBox.setAttribute('data-emp-ldap', person.ldap);

                    if (index === reversedIntermediatePath.length - 1) {
                        personBox.classList.add('intermediate-person');
                    }
                    if (index === 0) {
                        personBox.classList.add('top-manager');
                    }

                    middleColumn.appendChild(personBox);

                    if (index < reversedIntermediatePath.length - 1) {
                        const arrow = document.createElement('div');
                        arrow.className = 'vertical-arrow';
                        middleColumn.appendChild(arrow);
                    }
                });
            }

            // RIGHT COLUMN: QT employees
            const rightColumn = document.createElement('div');
            rightColumn.className = 'hierarchy-column';

            // Add QT employee (aligned with intermediate person at bottom)
            const qtBox = createPersonBox(qtEmployee, 'qt', connectionStrength);
            qtBox.classList.add('qt-person-bottom');

            // Calculate how many empty spaces we need to push QT employee down
            // Use the actual display path (middleColumnPath) for accurate spacing
            let spacersNeeded = 0;
            if (intermediatePerson && intermediatePathToShared.length > 0) {
                // Build the same display path as middle column (filter out people in left column)
                // Use trimmed path (up to first shared manager)
                const leftColumnLdaps = new Set(leftColumnPath.map(emp => emp.ldap));
                let displayPath = intermediatePathToShared.filter(emp =>
                    !leftColumnLdaps.has(emp.ldap)
                );

                // Find intermediate person position in the display path
                const qtEmployeeIndex = displayPath.findIndex(emp => emp.ldap === intermediateLdap);
                spacersNeeded = displayPath.length - qtEmployeeIndex - 1;
            }

            // Add spacers to align QT employee with intermediate person
            for (let i = 0; i < spacersNeeded; i++) {
                const spacer = document.createElement('div');
                spacer.style.height = '280px'; // Height of person-box (200px) + arrow (50px) + margins (30px)
                rightColumn.appendChild(spacer);
            }

            rightColumn.appendChild(qtBox);

            container.appendChild(leftColumn);
            container.appendChild(middleColumn);
            container.appendChild(rightColumn);

            // Add horizontal connector arrows after DOM is rendered
            setTimeout(() => {
                const horizontalGap = 40; // Gap between card edge and connector line

                // Connect intermediate person to QT employee
                const intermediatePerson = middleColumn.querySelector('.intermediate-person');
                const qtPerson = rightColumn.querySelector('.qt-person-bottom');

                if (intermediatePerson && qtPerson) {
                    const connectorLine = document.createElement('div');
                    connectorLine.className = 'horizontal-connector to-qt';

                    const leftRect = intermediatePerson.getBoundingClientRect();
                    const rightRect = qtPerson.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const top = leftRect.top - containerRect.top + (leftRect.height / 2);
                    const left = leftRect.right - containerRect.left + horizontalGap;
                    const width = rightRect.left - leftRect.right - (horizontalGap * 2);

                    connectorLine.style.top = `${top}px`;
                    connectorLine.style.left = `${left}px`;
                    connectorLine.style.width = `${width}px`;

                    container.appendChild(connectorLine);
                }

                // Connect managers between left and middle columns
                const allMiddleBoxes = Array.from(middleColumn.querySelectorAll('[data-emp-ldap]'));
                const allLeftBoxes = Array.from(leftColumn.querySelectorAll('[data-emp-ldap]'));

                // If we have 3 columns (middle column has people), ALWAYS connect the top cards
                // This shows the divergence point between the two organizational paths
                if (allMiddleBoxes.length > 0 && allLeftBoxes.length > 0) {
                    const middleTopBox = allMiddleBoxes[0];
                    const leftTopBox = allLeftBoxes[0];

                    const connector = document.createElement('div');
                    connector.className = 'horizontal-connector';

                    const leftRect = leftTopBox.getBoundingClientRect();
                    const rightRect = middleTopBox.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const top = leftRect.top - containerRect.top + (leftRect.height / 2);
                    const left = leftRect.right - containerRect.left + horizontalGap;
                    const width = rightRect.left - leftRect.right - (horizontalGap * 2);

                    connector.style.top = `${top}px`;
                    connector.style.left = `${left}px`;
                    connector.style.width = `${width}px`;

                    container.appendChild(connector);
                }

                // Build a map of ldap -> employee from leftColumnPath
                const leftEmployeeMap = {};
                leftColumnPath.forEach(emp => {
                    leftEmployeeMap[emp.ldap] = emp;
                });

                // For each person in left column, check if their manager is in middle column
                allLeftBoxes.forEach((leftBox, index) => {

                    const leftLdap = leftBox.getAttribute('data-emp-ldap');
                    const leftEmployee = leftEmployeeMap[leftLdap];

                    if (leftEmployee && leftEmployee.manager) {
                        // Extract manager LDAP from email
                        const managerLdap = leftEmployee.manager.split('@')[0].toLowerCase();

                        // Find if this manager exists in the middle column
                        const matchingMiddleBox = allMiddleBoxes.find(middleBox =>
                            middleBox.getAttribute('data-emp-ldap') === managerLdap
                        );

                        if (matchingMiddleBox) {
                            // Draw horizontal connector from left person to their manager in middle column
                            const connector = document.createElement('div');
                            connector.className = 'horizontal-connector';

                            const leftRect = leftBox.getBoundingClientRect();
                            const rightRect = matchingMiddleBox.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();

                            const top = leftRect.top - containerRect.top + (leftRect.height / 2);
                            const left = leftRect.right - containerRect.left + horizontalGap;
                            const width = rightRect.left - leftRect.right - (horizontalGap * 2);

                            connector.style.top = `${top}px`;
                            connector.style.left = `${left}px`;
                            connector.style.width = `${width}px`;

                            container.appendChild(connector);
                        }
                    }
                });
            }, 150);

            return container;
        }


        async function init() {
            await loadFlaskData();
            setupSearch();
            lucide.createIcons();
        }

        // Clean console - only connection paths

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>