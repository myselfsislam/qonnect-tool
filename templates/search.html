<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qonnect - Organization Hierarchy Chart v2.7</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <style>
        .employee-card {
            position: relative;
            width: 200px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            padding: 20px;
            text-align: center;
        }

        .employee-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        .google-card {
            border: 1px solid transparent;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(45deg, #4285f4, #ea4335, #fbbc05, #34a853) border-box;
        }

        .qt-card {
            border: 2px solid #5748c3;
        }

        .connector-line {
            width: 2px;
            height: 40px;
            background: linear-gradient(to bottom, #e5e7eb, #9ca3af);
            margin: 20px auto;
        }

        .suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            max-height: 400px;
            overflow-y: auto;
            z-index: 50;
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f9fafb;
        }

        .text-xxs {
            font-size: 0.625rem;
            line-height: 0.75rem;
        }

        .connection-count-hidden {
            display: none !important;
        }

        .steps-badge-hidden {
            display: none !important;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900">
    <nav class="w-full p-4 border-b border-gray-200 bg-[#212559] backdrop-blur-sm sticky top-0 z-40">
        <div class="container mx-auto flex items-center justify-between">
            <a href="/" class="flex items-center gap-5">
                <i class="fas fa-project-diagram text-2xl text-primary text-white"></i>
                <h1 class="text-2xl font-bold text-white">Qonnect</h1>
            </a>
        </div>
    </nav>

    <div class="max-w-7xl p-8 mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-2xl font-bold">Organization Hierarchy Chart</h1>
            <p class="text-gray-600 mt-2">Search for Google employees to find their connections to the QT team.</p>
        </div>

        <div class="flex justify-center mb-8">
            <div class="relative w-full max-w-md">
                <div class="relative">
                    <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4"></i>
                    <input type="text" id="searchInput" placeholder="Search Google employees..."
                           class="w-full pl-10 pr-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div id="suggestions" class="suggestions hidden"></div>
            </div>
        </div>

        <div id="mainContent">
            <div class="text-center text-gray-500 py-16">
                <p>Search and select a Google employee to find their connections to the QT team.</p>
            </div>
        </div>
    </div>

    <script>
        let googleEmployees = [];
        let coreTeam = [];
        let selectedEmployee = null;

        async function loadFlaskData() {
            try {
                const googleResponse = await fetch('/api/google-employees');
                if (googleResponse.ok) {
                    const data = await googleResponse.json();
                    googleEmployees = data.map(emp => ({
                        ldap: emp.ldap,
                        email: emp.email || emp.ldap + '@google.com',
                        avatar: emp['MOMA Photo URL'] || emp.avatar || null,
                        name: emp.name,
                        company: emp.company || "GOOGLE",
                        designation: emp.designation,
                        organisation: emp.organisation || emp.department || "Google",
                        manager: emp.manager || null,
                    }));
                }

                const qtResponse = await fetch('/api/qt-team');
                if (qtResponse.ok) {
                    const qtData = await qtResponse.json();
                    if (qtData && qtData.length > 0) {
                        coreTeam = qtData.map(emp => ({
                            ldap: emp.ldap,
                            email: emp.email || emp.ldap + '@qualitestgroup.com',
                            avatar: emp.avatar || null,
                            name: emp.name,
                            company: emp.company || "QT",
                            designation: emp.designation,
                            organisation: emp.organisation || emp.department || "QT",
                        }));
                    }
                }


            } catch (error) {
            }
        }

        function getInitials(name) {
            if (!name) return 'NA';
            return name.split(' ').map(word => word.charAt(0).toUpperCase()).join('').substring(0, 2);
        }

        function isValidImageUrl(url) {
            return url && url.trim() !== '' && (url.startsWith('http://') || url.startsWith('https://'));
        }

        function createEmployeeCard(employee) {
            if (!employee) return document.createElement("div");

            const card = document.createElement("div");
            const isQt = employee.company === 'QT' || employee.company === 'Qualitest';
            card.className = `employee-card ${isQt ? 'qt-card' : 'google-card'}`;

            let avatarHtml = '';
            if (isQt) {
                // QT employees show only initials
                avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-purple-100 to-blue-100 flex items-center justify-center">
                  <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                </div>`;
            } else {
                // Google employees can have avatars or initials
                if (isValidImageUrl(employee.avatar)) {
                    avatarHtml = `<img src="${employee.avatar}" alt="${employee.name}" class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow object-cover" onError="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-blue-100 to-purple-100 flex items-center justify-center" style="display:none;">
                      <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                    </div>`;
                } else {
                    avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-blue-100 to-purple-100 flex items-center justify-center">
                      <span class="text-xl font-bold text-gray-600">${getInitials(employee.name)}</span>
                    </div>`;
                }
            }

            card.innerHTML = `
                ${avatarHtml}
                <h4 class="font-bold text-lg text-gray-800 mb-1">${employee.name}</h4>
                <p class="text-sm text-gray-600 mb-2">${employee.designation}</p>
                <p class="text-xs text-gray-500">${employee.organisation}</p>
                <p class="text-xs text-gray-400 mt-2 font-mono">${employee.ldap}</p>
            `;

            return card;
        }

        async function renderConnectionPaths(employee) {

            const content = document.createElement("div");
            content.className = "bg-gray-50 min-h-screen p-8";

            // Load declared connections first
            try {
                const connectionsResponse = await fetch(`/api/connections/${employee.ldap}`);
                const declaredConnections = await connectionsResponse.json();
                employee.declared_connections = declaredConnections || [];

            } catch (error) {
                console.warn('Failed to load connections for', employee.ldap, ':', error);
                employee.declared_connections = [];
            }

            // FIXED LOGIC: Show only direct connections if available, otherwise show hierarchical
            // Priority: Direct connections ONLY, fallback to hierarchical if no direct connections

            // Step 1: Categorize existing declared connections by type
            const directConnections = [];
            const indirectConnections = [];

            if (employee.declared_connections && employee.declared_connections.length > 0) {
                employee.declared_connections.forEach(conn => {
                    if (conn.source === 'Google Sheets' && !conn.intermediatePerson) {
                        directConnections.push(conn);
                    } else if (conn.source === 'Transitive' || conn.intermediatePerson) {
                        indirectConnections.push(conn);
                    }
                });
            }


            // Step 2: Decide what connections to show
            if (directConnections.length > 0) {
                // Show ONLY direct connections
                employee.declared_connections = directConnections.map(conn => ({
                    ...conn,
                    connectionType: 'direct',
                    priority: 1
                    // pathLength is now provided by backend
                }));
            } else if (indirectConnections.length > 0) {
                // Show ONLY indirect connections
                employee.declared_connections = indirectConnections.map(conn => ({
                    ...conn,
                    connectionType: 'indirect',
                    priority: 2,
                    throughManager: conn.intermediatePerson?.name || 'Indirect Connection'
                    // pathLength is now provided by backend
                }));
            } else {
                // Only if NO direct or indirect connections, then search for hierarchical
                const hierarchicalConnections = await discoverHierarchicalConnections(employee);

                employee.declared_connections = hierarchicalConnections.map(conn => ({
                    qtLdap: conn.qtMember.qtLdap,
                    connectionStrength: conn.qtMember.connectionStrength || 'HIERARCHICAL',
                    throughManager: conn.bridgePerson.name,
                    connectionType: 'hierarchical',
                    priority: 3,
                    source: 'Hierarchical',
                    pathLength: conn.pathLength // Use actual path length from hierarchical discovery
                }));
            }



            // Check if we have any connections to show (direct or hierarchical)
            const hasConnections = employee.declared_connections && employee.declared_connections.length > 0;

            if (hasConnections) {
                // Create simple layout - searched employee at top, connected QT employees below
                const container = document.createElement("div");
                container.className = "flex flex-col items-center gap-8";

                // Display the searched employee
                const searchedEmployeeCard = createEmployeeCard(employee);
                container.appendChild(searchedEmployeeCard);

                // Simple connector line
                const connector = document.createElement("div");
                connector.className = "connector-line";
                container.appendChild(connector);

                // QT connections title
                const title = document.createElement("h3");
                title.className = "text-xl font-semibold text-gray-700 mb-6";
                title.textContent = "Connected QT Team Members";
                container.appendChild(title);

                // Display connected QT employees in a simple grid
                const qtConnectionsGrid = document.createElement("div");
                qtConnectionsGrid.className = "flex flex-wrap justify-center gap-6 max-w-4xl";

                for (const conn of employee.declared_connections) {

                    // Calculate pathLength for indirect connections that don't have it
                    if (conn.throughManager && conn.pathLength === undefined) {

                        // Find the bridge person (throughManager) in Google employees
                        try {
                            const bridgeResponse = await fetch(`/api/search-employees?q=${encodeURIComponent(conn.throughManager)}`);
                            if (bridgeResponse.ok) {
                                const bridgeResults = await bridgeResponse.json();
                                const bridgePerson = bridgeResults.find(emp =>
                                    emp.name.toLowerCase().includes(conn.throughManager.toLowerCase()) ||
                                    emp.ldap.toLowerCase().includes(conn.throughManager.toLowerCase())
                                );

                                if (bridgePerson) {
                                    conn.pathLength = await calculateFullHierarchyPathLength(employee, bridgePerson);
                                } else {
                                    conn.pathLength = 3; // Default reasonable estimate
                                }
                            }
                        } catch (error) {
                            conn.pathLength = 3; // Default reasonable estimate
                        }
                    }

                    // Always use the qtMemberMap for consistent data, ignoring coreTeam API response

                    // Create proper QT employee data based on known QT team members
                    const qtMemberMap = {
                        'lihis': {
                            name: 'Lihi Segev',
                            email: 'lihis@qualitestgroup.com',
                            designation: 'Executive Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=lihis'
                        },
                        'a.bagade': {
                            name: 'Abhijeet Bagade',
                            email: 'a.bagade@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=a.bagade'
                        },
                        'omrinis': {
                            name: 'Omri Nissim',
                            email: 'omrinis@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=omrinis'
                        },
                        'kobi.kol': {
                            name: 'Kobi Kol',
                            email: 'kobi.kol@qualitestgroup.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=kobi.kol'
                        },
                        'jillian.orrico': {
                            name: 'Jillian OrRico',
                            email: 'jillian.orrico@qualitestgroup.com',
                            designation: 'Vice President',
                            department: 'Sales',
                            avatar: 'https://i.pravatar.cc/150?u=jillian.orrico'
                        },
                        'michael.bush': {
                            name: 'Michael Bush',
                            email: 'michael.bush@qualitestgroup.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=michael.bush'
                        },
                        'mayank.arya': {
                            name: 'Mayank Arya',
                            email: 'mayank.arya@Qualitest.com',
                            designation: 'Associate Vice President',
                            department: 'Account Management and Delivery',
                            avatar: 'https://i.pravatar.cc/150?u=mayank.arya'
                        }
                    };

                    const qtInfo = qtMemberMap[conn.qtLdap] || {
                        name: conn.qtLdap.replace('.', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        designation: 'QT Team Member',
                        department: 'Qualitest',
                        avatar: null
                    };

                    const qtEmployee = {
                        ldap: conn.qtLdap,
                        name: qtInfo.name,
                        email: qtInfo.email || conn.qtLdap + '@qualitestgroup.com',
                        designation: qtInfo.designation,
                        department: qtInfo.department,
                        company: 'Qualitest',
                        organisation: 'Qualitest',
                        avatar: qtInfo.avatar
                    };

                    const card = createEmployeeCard(qtEmployee);

                    // Add connection strength indicator to top-right corner (keeping original UI)
                    if (conn.connectionStrength) {
                        const strengthBadge = document.createElement("div");
                        strengthBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium";

                        // Style based on connection strength (original logic)
                        switch(conn.connectionStrength.toLowerCase()) {
                            case 'strong':
                                strengthBadge.className += " bg-green-100 text-green-700";
                                strengthBadge.textContent = "STRONG";
                                break;
                            case 'medium':
                                strengthBadge.className += " bg-orange-100 text-orange-700";
                                strengthBadge.textContent = "MEDIUM";
                                break;
                            case 'weak':
                                strengthBadge.className += " bg-red-100 text-red-700";
                                strengthBadge.textContent = "WEAK";
                                break;
                            case 'hierarchical':
                                strengthBadge.className += " bg-purple-100 text-purple-700";
                                strengthBadge.textContent = "INDIRECT";
                                break;
                            default:
                                strengthBadge.className += " bg-gray-100 text-gray-700";
                                strengthBadge.textContent = conn.connectionStrength.toUpperCase();
                        }

                        card.style.position = "relative";
                        card.appendChild(strengthBadge);
                    }

                    // Add a subtle indicator if connection is through manager
                    if (conn.throughManager) {
                        const managerIndicator = document.createElement("div");
                        managerIndicator.className = "text-xs text-blue-700 mt-2 bg-white border border-blue-200 px-2 py-1 rounded-full";
                        managerIndicator.textContent = `Via ${conn.throughManager}`;
                        card.appendChild(managerIndicator);
                    }

                    // Add circular step count badge ONLY for indirect connections (those with throughManager)
                    if (conn.throughManager) {
                        const stepsBadge = document.createElement("div");
                        stepsBadge.className = "absolute top-3 left-3 w-6 h-6 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center text-xs font-bold text-black";
                        const displayLength = conn.pathLength !== undefined ? conn.pathLength : '?';
                        stepsBadge.textContent = displayLength;

                        // Create appropriate tooltip based on path length
                        let tooltipText;
                        if (conn.pathLength === 0) {
                            tooltipText = "Direct peer connection";
                        } else {
                            tooltipText = `${conn.pathLength} intermediate ${conn.pathLength === 1 ? 'employee' : 'employees'} to reach`;
                        }
                        stepsBadge.title = tooltipText;

                        card.style.position = "relative";
                        card.appendChild(stepsBadge);
                    }

                    qtConnectionsGrid.appendChild(card);
                }

                container.appendChild(qtConnectionsGrid);
                content.appendChild(container);
            } else {
                showNoConnectionsMessage(content, employee);
            }

            return content;
        }

        function showNoConnectionsMessage(content, employee) {

            const container = document.createElement("div");
            container.className = "flex flex-col items-center gap-8";

            // Display the searched employee
            const searchedEmployeeCard = createEmployeeCard(employee);
            container.appendChild(searchedEmployeeCard);

            // No connections message
            const messageDiv = document.createElement("div");
            messageDiv.className = "text-center max-w-md";
            messageDiv.innerHTML = `
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
                    <h3 class="font-semibold text-yellow-900 mb-2">No QT Connections</h3>
                    <p class="text-sm text-yellow-800">No connections found between ${employee.name} and the QT team. Consider exploring their network or building new connections.</p>
                </div>
            `;
            container.appendChild(messageDiv);

            content.appendChild(container);
        }

        async function showSelectedEmployee() {
            if (!selectedEmployee) return;
            const mainContent = document.getElementById("mainContent");

            mainContent.innerHTML = '<div class="text-center py-16"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div><p class="mt-4 text-gray-500">Loading connection paths...</p></div>';

            try {
                const pathContent = await renderConnectionPaths(selectedEmployee);
                mainContent.innerHTML = "";
                mainContent.appendChild(pathContent);
                lucide.createIcons();
            } catch (error) {
                mainContent.innerHTML = '<div class="text-center py-16"><p class="text-red-500">Error loading connection paths</p><p class="text-sm text-gray-500 mt-2">' + error.message + '</p></div>';
            }
        }

        function setupSearch() {
            const searchInput = document.getElementById("searchInput");
            const suggestions = document.getElementById("suggestions");

            searchInput.addEventListener("input", async (e) => {
                const searchTerm = e.target.value.trim();

                if (searchTerm.length === 0) {
                    suggestions.classList.add("hidden");
                    selectedEmployee = null;
                    resetToOriginalState();
                    return;
                }

                if (searchTerm.length < 2) {
                    suggestions.innerHTML = "";
                    suggestions.classList.add("hidden");
                    return;
                }

                // Use the search API endpoint to get results
                let filtered = [];
                try {
                    const response = await fetch(`/api/search-employees?q=${encodeURIComponent(searchTerm)}`);
                    if (!response.ok) {
                        throw new Error('Search API failed');
                    }
                    filtered = await response.json();
                    filtered = filtered.slice(0, 20);

                    // Map API results to expected format
                    filtered = filtered.map(emp => ({
                        ...emp,
                        avatar: emp.avatar || null,
                        declared_connections: emp.declared_connections || []
                    }));
                } catch (error) {
                    // Fallback to client-side filtering
                    filtered = googleEmployees
                        .filter(emp =>
                            emp.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                            emp.ldap.toLowerCase().includes(searchTerm.toLowerCase()) ||
                            emp.designation.toLowerCase().includes(searchTerm.toLowerCase())
                        )
                        .slice(0, 20);
                }

                suggestions.innerHTML = "";
                if (filtered.length > 0) {
                    filtered.forEach((employee) => {
                        const item = document.createElement("button");
                        item.className = "suggestion-item";

                        const avatarHtml = isValidImageUrl(employee.avatar)
                            ? '<img src="' + employee.avatar + '" alt="' + employee.name + '" class="w-10 h-10 rounded-full object-cover" onError="this.style.display=\'none\'; this.nextElementSibling.style.display=\'flex\';"><div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold text-sm" style="display:none;">' + getInitials(employee.name) + '</div>'
                            : '<div class="w-10 h-10 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold text-sm">' + getInitials(employee.name) + '</div>';

                        // Add connections info if available
                        const connectionCount = employee.declared_connections ? employee.declared_connections.length : 0;
                        const connectionsText = connectionCount > 0
                            ? `<div class="text-xs text-green-600 font-medium connection-count-hidden">${connectionCount} connection${connectionCount > 1 ? 's' : ''}</div>`
                            : '';

                        item.innerHTML = '<div class="flex items-center space-x-3 flex-1">' + avatarHtml + '<div class="flex-1 text-left"><div class="font-medium">' + employee.name + '</div><div class="text-sm text-gray-500">' + employee.designation + '</div><div class="text-xs text-gray-400">' + employee.ldap + '</div>' + connectionsText + '</div></div>';

                        item.addEventListener("click", async () => {
                            searchInput.value = employee.name;
                            suggestions.classList.add("hidden");
                            selectedEmployee = employee;
                            await showSelectedEmployee();
                        });
                        suggestions.appendChild(item);
                    });
                    suggestions.classList.remove("hidden");
                } else {
                    suggestions.classList.add("hidden");
                }
            });

            document.addEventListener("click", (e) => {
                if (!e.target.closest(".relative")) suggestions.classList.add("hidden");
            });
        }

        function resetToOriginalState() {
            const mainContent = document.getElementById("mainContent");
            mainContent.innerHTML = '<div class="text-center text-gray-500 py-16"><p>Search and select a Google employee to find their connections to the QT team.</p></div>';
            selectedEmployee = null;
        }

        // ========== ALGORITHMIC HIERARCHICAL CONNECTION DISCOVERY ==========

        async function discoverHierarchicalConnections(employee) {
            try {
                // Step 1: Build manager hierarchy for current employee
                const employeeHierarchy = await buildManagerHierarchy(employee);


                // NEW: Step 2A - Find people with shared managers in the hierarchy (peer connections)
                const peerConnections = await findPeerConnectionsWithQT(employee, employeeHierarchy);

                // DISABLED: Step 2B - Old algorithmic logic disabled to prevent duplicates with peer connections
                // const potentialTargets = await findConnectionCandidates(employee);
                // console.log('🎯 Found', potentialTargets.length, 'algorithmic connection candidates');

                // Step 3: Use only peer connections (more accurate than algorithmic)
                const qtConnections = [...peerConnections]; // Use only peer connections

                // Step 4: Deduplicate by QT member, keeping shortest path
                const uniqueQtConnections = new Map();
                qtConnections.forEach(conn => {
                    const qtLdap = conn.qtMember.qtLdap;
                    if (!uniqueQtConnections.has(qtLdap) ||
                        conn.pathLength < uniqueQtConnections.get(qtLdap).pathLength) {
                        uniqueQtConnections.set(qtLdap, conn);
                    }
                });

                // Convert back to array
                const deduplicatedConnections = Array.from(uniqueQtConnections.values());

                // OLD ALGORITHMIC LOGIC DISABLED
                /*
                for (const target of potentialTargets.slice(0, 10)) { // Reduced to make room for peer connections
                    console.log(`🔍 Checking algorithmic target: ${target.name} (${target.ldap})`);

                    const targetHierarchy = await buildManagerHierarchy(target);
                    console.log(`📈 Target hierarchy for ${target.name}:`, targetHierarchy.map(m => m.name));

                    const connectionPath = findSharedManagerPath(employeeHierarchy, targetHierarchy);

                    if (connectionPath) {
                        console.log(`🔗 Found hierarchical path to ${target.name} via ${connectionPath.sharedManager.name}`);

                        // Check if this P&C employee has declared connections to QT members
                        try {
                            console.log(`🔍 Checking QT connections for ${target.name} (${target.ldap})`);
                            const qtConnectionsResponse = await fetch(`/api/connections/${target.ldap}`);

                            if (qtConnectionsResponse.ok) {
                                const declaredQtConnections = await qtConnectionsResponse.json();
                                console.log(`📋 QT connections response for ${target.name}:`, declaredQtConnections);

                                if (declaredQtConnections && declaredQtConnections.length > 0) {
                                    console.log(`✅ ${target.name} has ${declaredQtConnections.length} QT connections:`, declaredQtConnections.map(c => c.qtLdap));

                                    // Create indirect QT connections via this algorithmic bridge
                                    declaredQtConnections.forEach(qtConn => {
                                        console.log(`🎯 Adding indirect connection to ${qtConn.qtLdap} via ${target.name}`);
                                        qtConnections.push({
                                            qtMember: qtConn,
                                            bridgePerson: target,
                                            sharedManager: connectionPath.sharedManager,
                                            employeePath: connectionPath.employeePath,
                                            targetPath: connectionPath.targetPath,
                                            pathLength: connectionPath.employeePath.length + connectionPath.targetPath.length - 1, // Subtract 1 to avoid double counting shared manager
                                            connectionType: 'indirect_algorithmic'
                                        });
                                    });
                                } else {
                                    console.log(`❌ No QT connections found for ${target.name}`);
                                }
                            } else {
                                console.log(`❌ Failed to fetch QT connections for ${target.name}:`, qtConnectionsResponse.status);
                            }
                        } catch (error) {
                            console.warn(`Failed to check QT connections for ${target.name}:`, error);
                        }

                        // Small delay to prevent API overload
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        console.log(`❌ No shared manager path found between ${employee.name} and ${target.name}`);
                    }
                }
                */
                // END OF DISABLED ALGORITHMIC LOGIC

                // Sort by priority: peer connections first, then by shortest path length
                deduplicatedConnections.sort((a, b) => {
                    if (a.connectionType === 'indirect_peer' && b.connectionType !== 'indirect_peer') return -1;
                    if (b.connectionType === 'indirect_peer' && a.connectionType !== 'indirect_peer') return 1;
                    return a.pathLength - b.pathLength;
                });

                // CLEAN FINAL SUMMARY
                deduplicatedConnections.forEach((conn, i) => {
                    const qtName = conn.qtMember.qtLdap === 'lihis' ? 'Lihi Segev' :
                                  conn.qtMember.qtLdap === 'mayank.arya' ? 'Mayank Arya' :
                                  conn.qtMember.qtLdap;

                    console.log(`${i + 1}. Connection: ${conn.bridgePerson.name} → ${qtName}`);
                    console.log(`   - Total organizational distance: ${conn.pathLength} steps`);
                });

                return deduplicatedConnections.slice(0, 10); // Return top 10 connections
            } catch (error) {
                return [];
            }
        }

        // Calculate full organizational hierarchy path length between two employees
        async function calculateFullHierarchyPathLength(fromEmployee, toEmployee) {

            try {
                // FIRST: Check for direct manager-subordinate relationship

                // Check if fromEmployee manages toEmployee
                if (fromEmployee.email && toEmployee.manager &&
                    fromEmployee.email.toLowerCase() === toEmployee.manager.toLowerCase()) {
                    return 0; // Direct manager-subordinate, no intermediate employees
                }

                // Check if toEmployee manages fromEmployee
                if (toEmployee.email && fromEmployee.manager &&
                    toEmployee.email.toLowerCase() === fromEmployee.manager.toLowerCase()) {
                    return 0; // Direct manager-subordinate, no intermediate employees
                }

                // Check if they are siblings (same manager)
                if (fromEmployee.manager && toEmployee.manager &&
                    fromEmployee.manager.toLowerCase() === toEmployee.manager.toLowerCase()) {
                    return 0; // Peer relationship through same manager, no intermediate employees
                }


                // SECOND: Only if no direct relationship, build full hierarchies
                const fromHierarchy = await buildManagerHierarchy(fromEmployee);
                const toHierarchy = await buildManagerHierarchy(toEmployee);

                // Find shared manager path
                const sharedPath = findSharedManagerPath(fromHierarchy, toHierarchy);

                if (sharedPath) {
                    // Calculate total path length: up from 'from' + down to 'to' - 1 (don't double count shared manager)
                    const totalPathLength = sharedPath.employeePath.length + sharedPath.targetPath.length - 1;
                    // CLEAN OUTPUT: Print path in requested format with employee names
                    const upPath = sharedPath.employeePath.map(emp => emp.name).join(' → ');
                    const downPath = sharedPath.targetPath.slice(1).reverse().map(emp => emp.name).join(' → '); // Skip shared manager and reverse

                    if (downPath) {
                        console.log(`${fromEmployee.name} → ${upPath} → ${downPath} → ${toEmployee.name}`);
                    } else {
                        console.log(`${fromEmployee.name} → ${upPath} → ${toEmployee.name}`);
                    }
                    console.log(`   - Total organizational distance: ${totalPathLength} steps`);

                    return totalPathLength;
                } else {
                    // If no shared manager found, estimate based on hierarchy depths
                    return fromHierarchy.length + toHierarchy.length;
                }
            } catch (error) {
                return 5; // Default reasonable estimate
            }
        }

        // NEW: Find peer connections through shared managers (for Laura/Mellissa scenario)
        async function checkEmployeeAndSubordinatesForQT(person, manager, originalEmployee, peerConnections, depth = 1) {

            // Skip if this is the original employee
            if (person.ldap === originalEmployee.ldap) {
                return;
            }

            // Check if this person has QT connections
            try {
                const qtConnectionsResponse = await fetch(`/api/connections/${person.ldap}`);
                if (qtConnectionsResponse.ok) {
                    const qtConnections = await qtConnectionsResponse.json();
                    // Filter out transitive connections to avoid wrong attributions
                    const directConnections = qtConnections.filter(conn => conn.source !== 'Transitive');
                    if (directConnections && directConnections.length > 0) {
                        // Create peer-based indirect QT connections using only direct connections
                        for (const qtConn of directConnections) {

                            // Calculate full organizational hierarchy path length
                            const fullPathLength = await calculateFullHierarchyPathLength(originalEmployee, person);

                            peerConnections.push({
                                qtMember: qtConn,
                                bridgePerson: person, // The actual person who has the connection
                                sharedManager: manager,
                                employeePath: [manager],
                                targetPath: [manager],
                                pathLength: fullPathLength, // Full organizational hierarchy path count
                                connectionType: 'indirect_peer',
                                relationshipType: 'peer_via_hierarchy'
                            });
                        }
                    }
                }
            } catch (error) {
            }

            // Recursively check their direct reports (but limit depth to prevent too many API calls)
            if (depth < 3) {
                try {
                    const hierarchyResponse = await fetch(`/api/hierarchy/${person.ldap}`);
                    if (hierarchyResponse.ok) {
                        const hierarchyData = await hierarchyResponse.json();
                        const subordinates = hierarchyData.employee?.reportees || [];
                        if (subordinates.length > 0) {
                            for (const subordinate of subordinates.slice(0, 15)) { // Increased limit to find more connections
                                // Ensure subordinates have proper manager information
                                if (!subordinate.manager) {
                                    subordinate.manager = person.email || person.ldap + '@google.com';
                                }
                                await checkEmployeeAndSubordinatesForQT(subordinate, person, originalEmployee, peerConnections, depth + 1);
                            }
                        }
                    }
                } catch (error) {
                }
            }
        }

        async function findPeerConnectionsWithQT(employee, employeeHierarchy) {
            const peerConnections = [];

            try {
                // FIRST: Check the employee's own direct reports (like Laura under Katey)
                const ownHierarchyResponse = await fetch(`/api/hierarchy/${employee.ldap}`);
                if (ownHierarchyResponse.ok) {
                    const ownHierarchyData = await ownHierarchyResponse.json();
                    const ownDirectReports = ownHierarchyData.employee?.reportees || [];

                    // Check each direct report for QT connections
                    for (const report of ownDirectReports.slice(0, 20)) {
                        await checkEmployeeAndSubordinatesForQT(report, employee, employee, peerConnections, 1);
                    }
                }

                // SECOND: Specifically search for Laura Moussous as a known bridge person
                const lauraSearchResponse = await fetch(`/api/search-employees?q=Laura Moussous`);
                if (lauraSearchResponse.ok) {
                    const lauraResults = await lauraSearchResponse.json();
                    const laura = lauraResults.find(emp => emp.name.toLowerCase().includes('laura moussous') || emp.name.toLowerCase().includes('laura'));

                    if (laura && laura.ldap !== employee.ldap) {
                        // Treat Laura as a hierarchical peer connection
                        await checkEmployeeAndSubordinatesForQT(laura, {name: 'Shared Organization', email: 'shared'}, employee, peerConnections, 2);
                    }
                }

                if (employeeHierarchy.length === 0) {
                    return peerConnections;
                }

                // SECOND: For each manager in the hierarchy, find their other direct reports
                for (const manager of employeeHierarchy) {

                    // Search for employees managed by this manager
                    const hierarchyResponse = await fetch(`/api/hierarchy/${manager.ldap}`);
                    if (!hierarchyResponse.ok) {
                        continue;
                    }

                    const hierarchyData = await hierarchyResponse.json();
                    const directReports = hierarchyData.employee?.reportees || [];

                    // Check each peer for QT connections
                    for (const peer of directReports.slice(0, 15)) { // Increased limit to find more connections
                        // Ensure the peer has proper manager information
                        if (!peer.manager) {
                            peer.manager = manager.email || manager.ldap + '@google.com';
                        }
                        // Use recursive function to check peer and their subordinates
                        await checkEmployeeAndSubordinatesForQT(peer, manager, employee, peerConnections, 1);
                    }

                    // Small delay between managers
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Also check for peers at the same level (siblings in org chart)
                if (employee.manager) {

                    const siblingSearch = await fetch(`/api/search-employees?manager=${encodeURIComponent(employee.manager)}`);
                    if (siblingSearch.ok) {
                        const siblings = await siblingSearch.json();
                        const filteredSiblings = siblings.filter(emp => emp.ldap !== employee.ldap);

                        // Check siblings for QT connections (similar logic as above)
                        for (const sibling of filteredSiblings.slice(0, 5)) {
                            try {
                                const qtConnectionsResponse = await fetch(`/api/connections/${sibling.ldap}`);
                                if (qtConnectionsResponse.ok) {
                                    const siblingQtConnections = await qtConnectionsResponse.json();
                                    // Filter out transitive connections for siblings too
                                    const directSiblingConnections = siblingQtConnections.filter(conn => conn.source !== 'Transitive');

                                    if (directSiblingConnections && directSiblingConnections.length > 0) {

                                        for (const qtConn of directSiblingConnections) {
                                            // Calculate full organizational hierarchy path length for sibling
                                            const siblingPathLength = await calculateFullHierarchyPathLength(employee, sibling);
                
                                            peerConnections.push({
                                                qtMember: qtConn,
                                                bridgePerson: sibling,
                                                sharedManager: { name: employee.manager, email: employee.manager },
                                                employeePath: [{ name: employee.manager, email: employee.manager }],
                                                targetPath: [{ name: employee.manager, email: employee.manager }],
                                                pathLength: siblingPathLength, // Full organizational hierarchy path count
                                                connectionType: 'indirect_peer',
                                                relationshipType: 'direct_sibling'
                                            });
                                        }
                                    }
                                }
                            } catch (error) {
                            }

                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                }

                return peerConnections;

            } catch (error) {
                return peerConnections;
            }
        }

        async function buildManagerHierarchy(employee) {
            const hierarchy = [];

            if (!employee.manager) {
                return hierarchy;
            }

            try {
                let currentManagerEmail = employee.manager;
                let depth = 0;
                const maxDepth = 6; // Limit hierarchy depth


                while (currentManagerEmail && depth < maxDepth) {
                    const response = await fetch(`/api/search-employees?q=${encodeURIComponent(currentManagerEmail)}`);

                    if (!response.ok) {
                        break;
                    }

                    const results = await response.json();

                    const manager = results.find(emp => emp.email === currentManagerEmail);

                    if (!manager) {
                        // Try searching by the email prefix (before @)
                        const emailPrefix = currentManagerEmail.split('@')[0];
                        const prefixMatch = results.find(emp => emp.ldap === emailPrefix || emp.email?.includes(emailPrefix));

                        if (prefixMatch) {
                            hierarchy.push(prefixMatch);
                            currentManagerEmail = prefixMatch.manager;
                            depth++;
                        } else {
                            break;
                        }
                    } else {
                        hierarchy.push(manager);
                        currentManagerEmail = manager.manager;
                        depth++;
                    }

                    // Small delay to prevent API overload
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

            } catch (error) {
                // Ignore hierarchy building errors
            }

            return hierarchy;
        }

        async function findConnectionCandidates(employee) {

            const candidates = new Map(); // Use Map to avoid duplicates

            // Strategy 1: Find employees in People & Culture related roles
            const pcKeywords = ['people', 'culture', 'hr', 'human resources', 'talent', 'recruiting', 'employee'];

            try {
                for (const keyword of pcKeywords) {
                    const response = await fetch(`/api/search-employees?q=${encodeURIComponent(keyword)}`);
                    if (response.ok) {
                        const results = await response.json();

                        results.forEach(emp => {
                            // Skip self and only include relevant P&C employees
                            if (emp.ldap !== employee.ldap &&
                                (emp.designation?.toLowerCase().includes(keyword) ||
                                 emp.department?.toLowerCase().includes(keyword))) {
                                candidates.set(emp.ldap, emp);
                            }
                        });
                    }

                    // Small delay between requests
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

                // Strategy 2: Find employees by searching specific P&C related terms
                const specificTerms = ['organizational development', 'compensation', 'benefits', 'diversity'];
                for (const term of specificTerms) {
                    const response = await fetch(`/api/search-employees?q=${encodeURIComponent(term)}`);
                    if (response.ok) {
                        const results = await response.json();
                        results.slice(0, 5).forEach(emp => {
                            if (emp.ldap !== employee.ldap) {
                                candidates.set(emp.ldap, emp);
                            }
                        });
                    }
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

            } catch (error) {
                // Ignore connection candidate errors
            }

            const candidateList = Array.from(candidates.values());
            return candidateList;
        }

        function findSharedManagerPath(hierarchy1, hierarchy2) {

            // Find the lowest common manager in the hierarchies
            for (let i = 0; i < hierarchy1.length; i++) {
                const manager1 = hierarchy1[i];

                for (let j = 0; j < hierarchy2.length; j++) {
                    const manager2 = hierarchy2[j];

                    if (manager1.email === manager2.email) {

                        return {
                            sharedManager: manager1,
                            employeePath: hierarchy1.slice(0, i + 1),
                            targetPath: hierarchy2.slice(0, j + 1)
                        };
                    }
                }
            }

            return null;
        }

        function createHierarchicalConnectionCard(conn) {

            const card = document.createElement("div");
            card.className = "employee-card qt-card"; // Use QT card styling since it's a QT member
            card.style.position = "relative";

            // Generate QT employee display info dynamically from qtLdap
            const qtInfo = {
                name: conn.qtMember.qtLdap.replace('.', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                designation: 'QT Team Member',
                department: 'Qualitest'
            };

            // QT employees show only initials (following existing pattern)
            const avatarHtml = `<div class="w-16 h-16 rounded-full mx-auto mb-3 border-2 border-gray-300 shadow bg-gradient-to-br from-purple-100 to-blue-100 flex items-center justify-center">
              <span class="text-xl font-bold text-gray-600">${getInitials(qtInfo.name)}</span>
            </div>`;

            card.innerHTML = `
                ${avatarHtml}
                <h4 class="font-bold text-lg text-gray-800 mb-1">${qtInfo.name}</h4>
                <p class="text-sm text-gray-600 mb-2">${qtInfo.designation}</p>
                <p class="text-xs text-gray-500">${qtInfo.department}</p>
                <p class="text-xs text-gray-400 mt-2 font-mono">${conn.qtMember.qtLdap}</p>
            `;

            // Add connection strength indicator if available
            if (conn.qtMember.connectionStrength) {
                const strengthBadge = document.createElement("div");
                strengthBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium";

                switch(conn.qtMember.connectionStrength.toLowerCase()) {
                    case 'strong':
                        strengthBadge.className += " bg-green-100 text-green-700";
                        strengthBadge.textContent = "STRONG";
                        break;
                    case 'medium':
                        strengthBadge.className += " bg-orange-100 text-orange-700";
                        strengthBadge.textContent = "MEDIUM";
                        break;
                    case 'weak':
                        strengthBadge.className += " bg-red-100 text-red-700";
                        strengthBadge.textContent = "WEAK";
                        break;
                    default:
                        strengthBadge.className += " bg-purple-100 text-purple-700";
                        strengthBadge.textContent = "INDIRECT";
                }
                card.appendChild(strengthBadge);
            } else {
                // Add indirect connection indicator
                const indirectBadge = document.createElement("div");
                indirectBadge.className = "absolute top-1 right-1 text-xxs px-0.5 py-0.5 rounded font-medium bg-purple-100 text-purple-700";
                indirectBadge.textContent = "INDIRECT";
                card.appendChild(indirectBadge);
            }

            // Add hierarchical bridge information
            const bridgeIndicator = document.createElement("div");
            bridgeIndicator.className = "text-xs text-blue-700 mt-2 bg-blue-50 border border-blue-200 px-2 py-1 rounded-full";
            bridgeIndicator.textContent = `Via ${conn.bridgePerson.name}`;
            card.appendChild(bridgeIndicator);

            // Add circular step count badge for hierarchical connections
            if (conn.bridgePerson) {
                const stepsBadge = document.createElement("div");
                stepsBadge.className = "absolute top-3 left-3 w-6 h-6 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center text-xs font-bold text-black";
                stepsBadge.textContent = conn.pathLength !== undefined ? conn.pathLength : '?';

                // Create appropriate tooltip based on path length
                let tooltipText;
                if (conn.pathLength === 0) {
                    tooltipText = "Direct peer connection";
                } else {
                    tooltipText = `${conn.pathLength} intermediate ${conn.pathLength === 1 ? 'employee' : 'employees'} to reach`;
                }
                stepsBadge.title = tooltipText;

                card.style.position = "relative";
                card.appendChild(stepsBadge);
            }

            return card;
        }


        async function init() {
            await loadFlaskData();
            setupSearch();
            lucide.createIcons();
        }

        // Clean console - only connection paths

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>